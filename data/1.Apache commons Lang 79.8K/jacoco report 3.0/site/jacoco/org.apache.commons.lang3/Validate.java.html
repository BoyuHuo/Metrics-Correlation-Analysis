<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Validate.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Commons Lang</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.lang3</a> &gt; <span class="el_source">Validate.java</span></div><h1>Validate.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.lang3;

import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.regex.Pattern;

/**
 * &lt;p&gt;This class assists in validating arguments. The validation methods are
 * based along the following principles:
 * &lt;ul&gt;
 *   &lt;li&gt;An invalid {@code null} argument causes a {@link NullPointerException}.&lt;/li&gt;
 *   &lt;li&gt;A non-{@code null} argument causes an {@link IllegalArgumentException}.&lt;/li&gt;
 *   &lt;li&gt;An invalid index into an array/collection/map/string causes an {@link IndexOutOfBoundsException}.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;All exceptions messages are
 * &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/api/java/util/Formatter.html#syntax&quot;&gt;format strings&lt;/a&gt;
 * as defined by the Java platform. For example:&lt;/p&gt;
 *
 * &lt;pre&gt;
 * Validate.isTrue(i &gt; 0, &quot;The value must be greater than zero: %d&quot;, i);
 * Validate.notNull(surname, &quot;The surname must not be %s&quot;, null);
 * &lt;/pre&gt;
 *
 * &lt;p&gt;#ThreadSafe#&lt;/p&gt;
 * @version $Id$
 * @see java.lang.String#format(String, Object...)
 * @since 2.0
 */
public class Validate {

    private static final String DEFAULT_EXCLUSIVE_BETWEEN_EX_MESSAGE =
        &quot;The value %s is not in the specified exclusive range of %s to %s&quot;;
    private static final String DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE =
        &quot;The value %s is not in the specified inclusive range of %s to %s&quot;;
    private static final String DEFAULT_MATCHES_PATTERN_EX = &quot;The string %s does not match the pattern %s&quot;;
    private static final String DEFAULT_IS_NULL_EX_MESSAGE = &quot;The validated object is null&quot;;
    private static final String DEFAULT_IS_TRUE_EX_MESSAGE = &quot;The validated expression is false&quot;;
    private static final String DEFAULT_NO_NULL_ELEMENTS_ARRAY_EX_MESSAGE =
        &quot;The validated array contains null element at index: %d&quot;;
    private static final String DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE =
        &quot;The validated collection contains null element at index: %d&quot;;
    private static final String DEFAULT_NOT_BLANK_EX_MESSAGE = &quot;The validated character sequence is blank&quot;;
    private static final String DEFAULT_NOT_EMPTY_ARRAY_EX_MESSAGE = &quot;The validated array is empty&quot;;
    private static final String DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE =
        &quot;The validated character sequence is empty&quot;;
    private static final String DEFAULT_NOT_EMPTY_COLLECTION_EX_MESSAGE = &quot;The validated collection is empty&quot;;
    private static final String DEFAULT_NOT_EMPTY_MAP_EX_MESSAGE = &quot;The validated map is empty&quot;;
    private static final String DEFAULT_VALID_INDEX_ARRAY_EX_MESSAGE = &quot;The validated array index is invalid: %d&quot;;
    private static final String DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE =
        &quot;The validated character sequence index is invalid: %d&quot;;
    private static final String DEFAULT_VALID_INDEX_COLLECTION_EX_MESSAGE =
        &quot;The validated collection index is invalid: %d&quot;;
    private static final String DEFAULT_VALID_STATE_EX_MESSAGE = &quot;The validated state is false&quot;;
    private static final String DEFAULT_IS_ASSIGNABLE_EX_MESSAGE =
        &quot;The validated class can not be converted to the %s class&quot;;
    private static final String DEFAULT_IS_INSTANCE_OF_EX_MESSAGE = &quot;The validated object is not an instance of %s&quot;;

    /**
     * Constructor. This class should not normally be instantiated.
     */
    public Validate() {
<span class="fc" id="L80">      super();</span>
<span class="fc" id="L81">    }</span>

    // isTrue
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validate that the argument condition is {@code true}; otherwise
     * throwing an exception with the specified message. This method is useful when
     * validating according to an arbitrary boolean expression, such as validating a
     * primitive number or using your own custom validation expression.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.isTrue(i &gt; 0.0, &quot;The value must be greater than zero: %d&quot;, i);&lt;/pre&gt;
     *
     * &lt;p&gt;For performance reasons, the long value is passed as a separate parameter and
     * appended to the exception message only in the case of an error.&lt;/p&gt;
     *
     * @param expression  the boolean expression to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param value  the value to append to the message when invalid
     * @throws IllegalArgumentException if expression is {@code false}
     * @see #isTrue(boolean)
     * @see #isTrue(boolean, String, double)
     * @see #isTrue(boolean, String, Object...)
     */
    public static void isTrue(boolean expression, String message, long value) {
<span class="fc bfc" id="L106" title="All 2 branches covered.">        if (expression == false) {</span>
<span class="fc" id="L107">            throw new IllegalArgumentException(String.format(message, Long.valueOf(value)));</span>
        }
<span class="fc" id="L109">    }</span>

    /**
     * &lt;p&gt;Validate that the argument condition is {@code true}; otherwise
     * throwing an exception with the specified message. This method is useful when
     * validating according to an arbitrary boolean expression, such as validating a
     * primitive number or using your own custom validation expression.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.isTrue(d &gt; 0.0, &quot;The value must be greater than zero: %s&quot;, d);&lt;/pre&gt;
     *
     * &lt;p&gt;For performance reasons, the double value is passed as a separate parameter and
     * appended to the exception message only in the case of an error.&lt;/p&gt;
     *
     * @param expression  the boolean expression to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param value  the value to append to the message when invalid
     * @throws IllegalArgumentException if expression is {@code false}
     * @see #isTrue(boolean)
     * @see #isTrue(boolean, String, long)
     * @see #isTrue(boolean, String, Object...)
     */
    public static void isTrue(boolean expression, String message, double value) {
<span class="fc bfc" id="L131" title="All 2 branches covered.">        if (expression == false) {</span>
<span class="fc" id="L132">            throw new IllegalArgumentException(String.format(message, new Double(value)));</span>
        }
<span class="fc" id="L134">    }</span>

    /**
     * &lt;p&gt;Validate that the argument condition is {@code true}; otherwise
     * throwing an exception with the specified message. This method is useful when
     * validating according to an arbitrary boolean expression, such as validating a
     * primitive number or using your own custom validation expression.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * Validate.isTrue(i &gt;= min &amp;&amp; i &lt;= max, &quot;The value must be between %d and %d&quot;, min, max);
     * Validate.isTrue(myObject.isOk(), &quot;The object is not okay&quot;);&lt;/pre&gt;
     *
     * @param expression  the boolean expression to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @throws IllegalArgumentException if expression is {@code false}
     * @see #isTrue(boolean)
     * @see #isTrue(boolean, String, long)
     * @see #isTrue(boolean, String, double)
     */
    public static void isTrue(boolean expression, String message, Object... values) {
<span class="fc bfc" id="L155" title="All 2 branches covered.">        if (expression == false) {</span>
<span class="fc" id="L156">            throw new IllegalArgumentException(String.format(message, values));</span>
        }
<span class="fc" id="L158">    }</span>

    /**
     * &lt;p&gt;Validate that the argument condition is {@code true}; otherwise
     * throwing an exception. This method is useful when validating according
     * to an arbitrary boolean expression, such as validating a
     * primitive number or using your own custom validation expression.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * Validate.isTrue(i &gt; 0);
     * Validate.isTrue(myObject.isOk());&lt;/pre&gt;
     *
     * &lt;p&gt;The message of the exception is &amp;quot;The validated expression is
     * false&amp;quot;.&lt;/p&gt;
     *
     * @param expression  the boolean expression to check
     * @throws IllegalArgumentException if expression is {@code false}
     * @see #isTrue(boolean, String, long)
     * @see #isTrue(boolean, String, double)
     * @see #isTrue(boolean, String, Object...)
     */
    public static void isTrue(boolean expression) {
<span class="fc bfc" id="L180" title="All 2 branches covered.">        if (expression == false) {</span>
<span class="fc" id="L181">            throw new IllegalArgumentException(DEFAULT_IS_TRUE_EX_MESSAGE);</span>
        }
<span class="fc" id="L183">    }</span>

    // notNull
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validate that the specified argument is not {@code null};
     * otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.notNull(myObject, &quot;The object must not be null&quot;);&lt;/pre&gt;
     *
     * &lt;p&gt;The message of the exception is &amp;quot;The validated object is
     * null&amp;quot;.&lt;/p&gt;
     *
     * @param &lt;T&gt; the object type
     * @param object  the object to check
     * @return the validated object (never {@code null} for method chaining)
     * @throws NullPointerException if the object is {@code null}
     * @see #notNull(Object, String, Object...)
     */
    public static &lt;T&gt; T notNull(T object) {
<span class="fc" id="L204">        return notNull(object, DEFAULT_IS_NULL_EX_MESSAGE);</span>
    }

    /**
     * &lt;p&gt;Validate that the specified argument is not {@code null};
     * otherwise throwing an exception with the specified message.
     *
     * &lt;pre&gt;Validate.notNull(myObject, &quot;The object must not be null&quot;);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the object type
     * @param object  the object to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message
     * @return the validated object (never {@code null} for method chaining)
     * @throws NullPointerException if the object is {@code null}
     * @see #notNull(Object)
     */
    public static &lt;T&gt; T notNull(T object, String message, Object... values) {
<span class="fc bfc" id="L222" title="All 2 branches covered.">        if (object == null) {</span>
<span class="fc" id="L223">            throw new NullPointerException(String.format(message, values));</span>
        }
<span class="fc" id="L225">        return object;</span>
    }

    // notEmpty array
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validate that the specified argument array is neither {@code null}
     * nor a length of zero (no elements); otherwise throwing an exception
     * with the specified message.
     *
     * &lt;pre&gt;Validate.notEmpty(myArray, &quot;The array must not be empty&quot;);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the array type
     * @param array  the array to check, validated not null by this method
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated array (never {@code null} method for chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IllegalArgumentException if the array is empty
     * @see #notEmpty(Object[])
     */
    public static &lt;T&gt; T[] notEmpty(T[] array, String message, Object... values) {
<span class="fc bfc" id="L248" title="All 2 branches covered.">        if (array == null) {</span>
<span class="fc" id="L249">            throw new NullPointerException(String.format(message, values));</span>
        }
<span class="fc bfc" id="L251" title="All 2 branches covered.">        if (array.length == 0) {</span>
<span class="fc" id="L252">            throw new IllegalArgumentException(String.format(message, values));</span>
        }
<span class="fc" id="L254">        return array;</span>
    }

    /**
     * &lt;p&gt;Validate that the specified argument array is neither {@code null}
     * nor a length of zero (no elements); otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.notEmpty(myArray);&lt;/pre&gt;
     *
     * &lt;p&gt;The message in the exception is &amp;quot;The validated array is
     * empty&amp;quot;.
     *
     * @param &lt;T&gt; the array type
     * @param array  the array to check, validated not null by this method
     * @return the validated array (never {@code null} method for chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IllegalArgumentException if the array is empty
     * @see #notEmpty(Object[], String, Object...)
     */
    public static &lt;T&gt; T[] notEmpty(T[] array) {
<span class="fc" id="L274">        return notEmpty(array, DEFAULT_NOT_EMPTY_ARRAY_EX_MESSAGE);</span>
    }

    // notEmpty collection
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validate that the specified argument collection is neither {@code null}
     * nor a size of zero (no elements); otherwise throwing an exception
     * with the specified message.
     *
     * &lt;pre&gt;Validate.notEmpty(myCollection, &quot;The collection must not be empty&quot;);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the collection type
     * @param collection  the collection to check, validated not null by this method
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated collection (never {@code null} method for chaining)
     * @throws NullPointerException if the collection is {@code null}
     * @throws IllegalArgumentException if the collection is empty
     * @see #notEmpty(Object[])
     */
    public static &lt;T extends Collection&lt;?&gt;&gt; T notEmpty(T collection, String message, Object... values) {
<span class="fc bfc" id="L297" title="All 2 branches covered.">        if (collection == null) {</span>
<span class="fc" id="L298">            throw new NullPointerException(String.format(message, values));</span>
        }
<span class="fc bfc" id="L300" title="All 2 branches covered.">        if (collection.size() == 0) {</span>
<span class="fc" id="L301">            throw new IllegalArgumentException(String.format(message, values));</span>
        }
<span class="fc" id="L303">        return collection;</span>
    }

    /**
     * &lt;p&gt;Validate that the specified argument collection is neither {@code null}
     * nor a size of zero (no elements); otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.notEmpty(myCollection);&lt;/pre&gt;
     *
     * &lt;p&gt;The message in the exception is &amp;quot;The validated collection is
     * empty&amp;quot;.&lt;/p&gt;
     *
     * @param &lt;T&gt; the collection type
     * @param collection  the collection to check, validated not null by this method
     * @return the validated collection (never {@code null} method for chaining)
     * @throws NullPointerException if the collection is {@code null}
     * @throws IllegalArgumentException if the collection is empty
     * @see #notEmpty(Collection, String, Object...)
     */
    public static &lt;T extends Collection&lt;?&gt;&gt; T notEmpty(T collection) {
<span class="fc" id="L323">        return notEmpty(collection, DEFAULT_NOT_EMPTY_COLLECTION_EX_MESSAGE);</span>
    }

    // notEmpty map
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validate that the specified argument map is neither {@code null}
     * nor a size of zero (no elements); otherwise throwing an exception
     * with the specified message.
     *
     * &lt;pre&gt;Validate.notEmpty(myMap, &quot;The map must not be empty&quot;);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the map type
     * @param map  the map to check, validated not null by this method
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated map (never {@code null} method for chaining)
     * @throws NullPointerException if the map is {@code null}
     * @throws IllegalArgumentException if the map is empty
     * @see #notEmpty(Object[])
     */
    public static &lt;T extends Map&lt;?, ?&gt;&gt; T notEmpty(T map, String message, Object... values) {
<span class="fc bfc" id="L346" title="All 2 branches covered.">        if (map == null) {</span>
<span class="fc" id="L347">            throw new NullPointerException(String.format(message, values));</span>
        }
<span class="fc bfc" id="L349" title="All 2 branches covered.">        if (map.size() == 0) {</span>
<span class="fc" id="L350">            throw new IllegalArgumentException(String.format(message, values));</span>
        }
<span class="fc" id="L352">        return map;</span>
    }

    /**
     * &lt;p&gt;Validate that the specified argument map is neither {@code null}
     * nor a size of zero (no elements); otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.notEmpty(myMap);&lt;/pre&gt;
     *
     * &lt;p&gt;The message in the exception is &amp;quot;The validated map is
     * empty&amp;quot;.&lt;/p&gt;
     *
     * @param &lt;T&gt; the map type
     * @param map  the map to check, validated not null by this method
     * @return the validated map (never {@code null} method for chaining)
     * @throws NullPointerException if the map is {@code null}
     * @throws IllegalArgumentException if the map is empty
     * @see #notEmpty(Map, String, Object...)
     */
    public static &lt;T extends Map&lt;?, ?&gt;&gt; T notEmpty(T map) {
<span class="fc" id="L372">        return notEmpty(map, DEFAULT_NOT_EMPTY_MAP_EX_MESSAGE);</span>
    }

    // notEmpty string
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validate that the specified argument character sequence is
     * neither {@code null} nor a length of zero (no characters);
     * otherwise throwing an exception with the specified message.
     *
     * &lt;pre&gt;Validate.notEmpty(myString, &quot;The string must not be empty&quot;);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the character sequence type
     * @param chars  the character sequence to check, validated not null by this method
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated character sequence (never {@code null} method for chaining)
     * @throws NullPointerException if the character sequence is {@code null}
     * @throws IllegalArgumentException if the character sequence is empty
     * @see #notEmpty(CharSequence)
     */
    public static &lt;T extends CharSequence&gt; T notEmpty(T chars, String message, Object... values) {
<span class="fc bfc" id="L395" title="All 2 branches covered.">        if (chars == null) {</span>
<span class="fc" id="L396">            throw new NullPointerException(String.format(message, values));</span>
        }
<span class="fc bfc" id="L398" title="All 2 branches covered.">        if (chars.length() == 0) {</span>
<span class="fc" id="L399">            throw new IllegalArgumentException(String.format(message, values));</span>
        }
<span class="fc" id="L401">        return chars;</span>
    }

    /**
     * &lt;p&gt;Validate that the specified argument character sequence is
     * neither {@code null} nor a length of zero (no characters);
     * otherwise throwing an exception with the specified message.
     *
     * &lt;pre&gt;Validate.notEmpty(myString);&lt;/pre&gt;
     *
     * &lt;p&gt;The message in the exception is &amp;quot;The validated
     * character sequence is empty&amp;quot;.&lt;/p&gt;
     *
     * @param &lt;T&gt; the character sequence type
     * @param chars  the character sequence to check, validated not null by this method
     * @return the validated character sequence (never {@code null} method for chaining)
     * @throws NullPointerException if the character sequence is {@code null}
     * @throws IllegalArgumentException if the character sequence is empty
     * @see #notEmpty(CharSequence, String, Object...)
     */
    public static &lt;T extends CharSequence&gt; T notEmpty(T chars) {
<span class="fc" id="L422">        return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);</span>
    }

    // notBlank string
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validate that the specified argument character sequence is
     * neither {@code null}, a length of zero (no characters), empty
     * nor whitespace; otherwise throwing an exception with the specified
     * message.
     *
     * &lt;pre&gt;Validate.notBlank(myString, &quot;The string must not be blank&quot;);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the character sequence type
     * @param chars  the character sequence to check, validated not null by this method
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated character sequence (never {@code null} method for chaining)
     * @throws NullPointerException if the character sequence is {@code null}
     * @throws IllegalArgumentException if the character sequence is blank
     * @see #notBlank(CharSequence)
     *
     * @since 3.0
     */
    public static &lt;T extends CharSequence&gt; T notBlank(T chars, String message, Object... values) {
<span class="fc bfc" id="L448" title="All 2 branches covered.">        if (chars == null) {</span>
<span class="fc" id="L449">            throw new NullPointerException(String.format(message, values));</span>
        }
<span class="fc bfc" id="L451" title="All 2 branches covered.">        if (StringUtils.isBlank(chars)) {</span>
<span class="fc" id="L452">            throw new IllegalArgumentException(String.format(message, values));</span>
        }
<span class="fc" id="L454">        return chars;</span>
    }

    /**
     * &lt;p&gt;Validate that the specified argument character sequence is
     * neither {@code null}, a length of zero (no characters), empty
     * nor whitespace; otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.notBlank(myString);&lt;/pre&gt;
     *
     * &lt;p&gt;The message in the exception is &amp;quot;The validated character
     * sequence is blank&amp;quot;.&lt;/p&gt;
     *
     * @param &lt;T&gt; the character sequence type
     * @param chars  the character sequence to check, validated not null by this method
     * @return the validated character sequence (never {@code null} method for chaining)
     * @throws NullPointerException if the character sequence is {@code null}
     * @throws IllegalArgumentException if the character sequence is blank
     * @see #notBlank(CharSequence, String, Object...)
     *
     * @since 3.0
     */
    public static &lt;T extends CharSequence&gt; T notBlank(T chars) {
<span class="fc" id="L477">        return notBlank(chars, DEFAULT_NOT_BLANK_EX_MESSAGE);</span>
    }

    // noNullElements array
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validate that the specified argument array is neither
     * {@code null} nor contains any elements that are {@code null};
     * otherwise throwing an exception with the specified message.
     *
     * &lt;pre&gt;Validate.noNullElements(myArray, &quot;The array contain null at position %d&quot;);&lt;/pre&gt;
     *
     * &lt;p&gt;If the array is {@code null}, then the message in the exception
     * is &amp;quot;The validated object is null&amp;quot;.&lt;/p&gt;
     *
     * &lt;p&gt;If the array has a {@code null} element, then the iteration
     * index of the invalid element is appended to the {@code values}
     * argument.&lt;/p&gt;
     *
     * @param &lt;T&gt; the array type
     * @param array  the array to check, validated not null by this method
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated array (never {@code null} method for chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IllegalArgumentException if an element is {@code null}
     * @see #noNullElements(Object[])
     */
    public static &lt;T&gt; T[] noNullElements(T[] array, String message, Object... values) {
<span class="fc" id="L507">        Validate.notNull(array);</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">        for (int i = 0; i &lt; array.length; i++) {</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">            if (array[i] == null) {</span>
<span class="fc" id="L510">                Object[] values2 = ArrayUtils.add(values, Integer.valueOf(i));</span>
<span class="fc" id="L511">                throw new IllegalArgumentException(String.format(message, values2));</span>
            }
        }
<span class="fc" id="L514">        return array;</span>
    }

    /**
     * &lt;p&gt;Validate that the specified argument array is neither
     * {@code null} nor contains any elements that are {@code null};
     * otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.noNullElements(myArray);&lt;/pre&gt;
     *
     * &lt;p&gt;If the array is {@code null}, then the message in the exception
     * is &amp;quot;The validated object is null&amp;quot;.&lt;/p&gt;
     *
     * &lt;p&gt;If the array has a {@code null} element, then the message in the
     * exception is &amp;quot;The validated array contains null element at index:
     * &amp;quot followed by the index.&lt;/p&gt;
     *
     * @param &lt;T&gt; the array type
     * @param array  the array to check, validated not null by this method
     * @return the validated array (never {@code null} method for chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IllegalArgumentException if an element is {@code null}
     * @see #noNullElements(Object[], String, Object...)
     */
    public static &lt;T&gt; T[] noNullElements(T[] array) {
<span class="fc" id="L539">        return noNullElements(array, DEFAULT_NO_NULL_ELEMENTS_ARRAY_EX_MESSAGE);</span>
    }

    // noNullElements iterable
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validate that the specified argument iterable is neither
     * {@code null} nor contains any elements that are {@code null};
     * otherwise throwing an exception with the specified message.
     *
     * &lt;pre&gt;Validate.noNullElements(myCollection, &quot;The collection contains null at position %d&quot;);&lt;/pre&gt;
     *
     * &lt;p&gt;If the iterable is {@code null}, then the message in the exception
     * is &amp;quot;The validated object is null&amp;quot;.&lt;/p&gt;
     *
     * &lt;p&gt;If the iterable has a {@code null} element, then the iteration
     * index of the invalid element is appended to the {@code values}
     * argument.&lt;/p&gt;
     *
     * @param &lt;T&gt; the iterable type
     * @param iterable  the iterable to check, validated not null by this method
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated iterable (never {@code null} method for chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IllegalArgumentException if an element is {@code null}
     * @see #noNullElements(Iterable)
     */
    public static &lt;T extends Iterable&lt;?&gt;&gt; T noNullElements(T iterable, String message, Object... values) {
<span class="fc" id="L569">        Validate.notNull(iterable);</span>
<span class="fc" id="L570">        int i = 0;</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">        for (Iterator&lt;?&gt; it = iterable.iterator(); it.hasNext(); i++) {</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">            if (it.next() == null) {</span>
<span class="fc" id="L573">                Object[] values2 = ArrayUtils.addAll(values, Integer.valueOf(i));</span>
<span class="fc" id="L574">                throw new IllegalArgumentException(String.format(message, values2));</span>
            }
        }
<span class="fc" id="L577">        return iterable;</span>
    }

    /**
     * &lt;p&gt;Validate that the specified argument iterable is neither
     * {@code null} nor contains any elements that are {@code null};
     * otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.noNullElements(myCollection);&lt;/pre&gt;
     *
     * &lt;p&gt;If the iterable is {@code null}, then the message in the exception
     * is &amp;quot;The validated object is null&amp;quot;.&lt;/p&gt;
     *
     * &lt;p&gt;If the array has a {@code null} element, then the message in the
     * exception is &amp;quot;The validated iterable contains null element at index:
     * &amp;quot followed by the index.&lt;/p&gt;
     *
     * @param &lt;T&gt; the iterable type
     * @param iterable  the iterable to check, validated not null by this method
     * @return the validated iterable (never {@code null} method for chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IllegalArgumentException if an element is {@code null}
     * @see #noNullElements(Iterable, String, Object...)
     */
    public static &lt;T extends Iterable&lt;?&gt;&gt; T noNullElements(T iterable) {
<span class="fc" id="L602">        return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE);</span>
    }

    // validIndex array
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validates that the index is within the bounds of the argument
     * array; otherwise throwing an exception with the specified message.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.validIndex(myArray, 2, &quot;The array index is invalid: &quot;);&lt;/pre&gt;
     *
     * &lt;p&gt;If the array is {@code null}, then the message of the exception
     * is &amp;quot;The validated object is null&amp;quot;.&lt;/p&gt;
     *
     * @param &lt;T&gt; the array type
     * @param array  the array to check, validated not null by this method
     * @param index  the index to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated array (never {@code null} for method chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IndexOutOfBoundsException if the index is invalid
     * @see #validIndex(Object[], int)
     *
     * @since 3.0
     */
    public static &lt;T&gt; T[] validIndex(T[] array, int index, String message, Object... values) {
<span class="fc" id="L630">        Validate.notNull(array);</span>
<span class="fc bfc" id="L631" title="All 4 branches covered.">        if (index &lt; 0 || index &gt;= array.length) {</span>
<span class="fc" id="L632">            throw new IndexOutOfBoundsException(String.format(message, values));</span>
        }
<span class="fc" id="L634">        return array;</span>
    }

    /**
     * &lt;p&gt;Validates that the index is within the bounds of the argument
     * array; otherwise throwing an exception.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.validIndex(myArray, 2);&lt;/pre&gt;
     *
     * &lt;p&gt;If the array is {@code null}, then the message of the exception
     * is &amp;quot;The validated object is null&amp;quot;.&lt;/p&gt;
     *
     * &lt;p&gt;If the index is invalid, then the message of the exception is
     * &amp;quot;The validated array index is invalid: &amp;quot; followed by the
     * index.&lt;/p&gt;
     *
     * @param &lt;T&gt; the array type
     * @param array  the array to check, validated not null by this method
     * @param index  the index to check
     * @return the validated array (never {@code null} for method chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IndexOutOfBoundsException if the index is invalid
     * @see #validIndex(Object[], int, String, Object...)
     *
     * @since 3.0
     */
    public static &lt;T&gt; T[] validIndex(T[] array, int index) {
<span class="fc" id="L661">        return validIndex(array, index, DEFAULT_VALID_INDEX_ARRAY_EX_MESSAGE, Integer.valueOf(index));</span>
    }

    // validIndex collection
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validates that the index is within the bounds of the argument
     * collection; otherwise throwing an exception with the specified message.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.validIndex(myCollection, 2, &quot;The collection index is invalid: &quot;);&lt;/pre&gt;
     *
     * &lt;p&gt;If the collection is {@code null}, then the message of the
     * exception is &amp;quot;The validated object is null&amp;quot;.&lt;/p&gt;
     *
     * @param &lt;T&gt; the collection type
     * @param collection  the collection to check, validated not null by this method
     * @param index  the index to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated collection (never {@code null} for chaining)
     * @throws NullPointerException if the collection is {@code null}
     * @throws IndexOutOfBoundsException if the index is invalid
     * @see #validIndex(Collection, int)
     *
     * @since 3.0
     */
    public static &lt;T extends Collection&lt;?&gt;&gt; T validIndex(T collection, int index, String message, Object... values) {
<span class="fc" id="L689">        Validate.notNull(collection);</span>
<span class="fc bfc" id="L690" title="All 4 branches covered.">        if (index &lt; 0 || index &gt;= collection.size()) {</span>
<span class="fc" id="L691">            throw new IndexOutOfBoundsException(String.format(message, values));</span>
        }
<span class="fc" id="L693">        return collection;</span>
    }

    /**
     * &lt;p&gt;Validates that the index is within the bounds of the argument
     * collection; otherwise throwing an exception.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.validIndex(myCollection, 2);&lt;/pre&gt;
     *
     * &lt;p&gt;If the index is invalid, then the message of the exception
     * is &amp;quot;The validated collection index is invalid: &amp;quot;
     * followed by the index.&lt;/p&gt;
     *
     * @param &lt;T&gt; the collection type
     * @param collection  the collection to check, validated not null by this method
     * @param index  the index to check
     * @return the validated collection (never {@code null} for method chaining)
     * @throws NullPointerException if the collection is {@code null}
     * @throws IndexOutOfBoundsException if the index is invalid
     * @see #validIndex(Collection, int, String, Object...)
     *
     * @since 3.0
     */
    public static &lt;T extends Collection&lt;?&gt;&gt; T validIndex(T collection, int index) {
<span class="fc" id="L717">        return validIndex(collection, index, DEFAULT_VALID_INDEX_COLLECTION_EX_MESSAGE, Integer.valueOf(index));</span>
    }

    // validIndex string
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validates that the index is within the bounds of the argument
     * character sequence; otherwise throwing an exception with the
     * specified message.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.validIndex(myStr, 2, &quot;The string index is invalid: &quot;);&lt;/pre&gt;
     *
     * &lt;p&gt;If the character sequence is {@code null}, then the message
     * of the exception is &amp;quot;The validated object is null&amp;quot;.&lt;/p&gt;
     *
     * @param &lt;T&gt; the character sequence type
     * @param chars  the character sequence to check, validated not null by this method
     * @param index  the index to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated character sequence (never {@code null} for method chaining)
     * @throws NullPointerException if the character sequence is {@code null}
     * @throws IndexOutOfBoundsException if the index is invalid
     * @see #validIndex(CharSequence, int)
     *
     * @since 3.0
     */
    public static &lt;T extends CharSequence&gt; T validIndex(T chars, int index, String message, Object... values) {
<span class="fc" id="L746">        Validate.notNull(chars);</span>
<span class="fc bfc" id="L747" title="All 4 branches covered.">        if (index &lt; 0 || index &gt;= chars.length()) {</span>
<span class="fc" id="L748">            throw new IndexOutOfBoundsException(String.format(message, values));</span>
        }
<span class="fc" id="L750">        return chars;</span>
    }

    /**
     * &lt;p&gt;Validates that the index is within the bounds of the argument
     * character sequence; otherwise throwing an exception.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.validIndex(myStr, 2);&lt;/pre&gt;
     *
     * &lt;p&gt;If the character sequence is {@code null}, then the message
     * of the exception is &amp;quot;The validated object is
     * null&amp;quot;.&lt;/p&gt;
     *
     * &lt;p&gt;If the index is invalid, then the message of the exception
     * is &amp;quot;The validated character sequence index is invalid: &amp;quot;
     * followed by the index.&lt;/p&gt;
     *
     * @param &lt;T&gt; the character sequence type
     * @param chars  the character sequence to check, validated not null by this method
     * @param index  the index to check
     * @return the validated character sequence (never {@code null} for method chaining)
     * @throws NullPointerException if the character sequence is {@code null}
     * @throws IndexOutOfBoundsException if the index is invalid
     * @see #validIndex(CharSequence, int, String, Object...)
     *
     * @since 3.0
     */
    public static &lt;T extends CharSequence&gt; T validIndex(T chars, int index) {
<span class="fc" id="L778">        return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index));</span>
    }

    // validState
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validate that the stateful condition is {@code true}; otherwise
     * throwing an exception. This method is useful when validating according
     * to an arbitrary boolean expression, such as validating a
     * primitive number or using your own custom validation expression.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * Validate.validState(field &gt; 0);
     * Validate.validState(this.isOk());&lt;/pre&gt;
     *
     * &lt;p&gt;The message of the exception is &amp;quot;The validated state is
     * false&amp;quot;.&lt;/p&gt;
     *
     * @param expression  the boolean expression to check
     * @throws IllegalStateException if expression is {@code false}
     * @see #validState(boolean, String, Object...)
     *
     * @since 3.0
     */
    public static void validState(boolean expression) {
<span class="nc bnc" id="L804" title="All 2 branches missed.">        if (expression == false) {</span>
<span class="nc" id="L805">            throw new IllegalStateException(DEFAULT_VALID_STATE_EX_MESSAGE);</span>
        }
<span class="nc" id="L807">    }</span>

    /**
     * &lt;p&gt;Validate that the stateful condition is {@code true}; otherwise
     * throwing an exception with the specified message. This method is useful when
     * validating according to an arbitrary boolean expression, such as validating a
     * primitive number or using your own custom validation expression.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.validState(this.isOk(), &quot;The state is not OK: %s&quot;, myObject);&lt;/pre&gt;
     *
     * @param expression  the boolean expression to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @throws IllegalStateException if expression is {@code false}
     * @see #validState(boolean)
     *
     * @since 3.0
     */
    public static void validState(boolean expression, String message, Object... values) {
<span class="nc bnc" id="L826" title="All 2 branches missed.">        if (expression == false) {</span>
<span class="nc" id="L827">            throw new IllegalStateException(String.format(message, values));</span>
        }
<span class="nc" id="L829">    }</span>

    // matchesPattern
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validate that the specified argument character sequence matches the specified regular
     * expression pattern; otherwise throwing an exception.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.matchesPattern(&quot;hi&quot;, &quot;[a-z]*&quot;);&lt;/pre&gt;
     *
     * &lt;p&gt;The syntax of the pattern is the one used in the {@link Pattern} class.&lt;/p&gt;
     *
     * @param input  the character sequence to validate, not null
     * @param pattern  the regular expression pattern, not null
     * @throws IllegalArgumentException if the character sequence does not match the pattern
     * @see #matchesPattern(CharSequence, String, String, Object...)
     *
     * @since 3.0
     */
    public static void matchesPattern(CharSequence input, String pattern) {
<span class="fc bfc" id="L850" title="All 2 branches covered.">        if (Pattern.matches(pattern, input) == false) {</span>
<span class="fc" id="L851">            throw new IllegalArgumentException(String.format(DEFAULT_MATCHES_PATTERN_EX, input, pattern));</span>
        }
<span class="fc" id="L853">    }</span>

    /**
     * &lt;p&gt;Validate that the specified argument character sequence matches the specified regular
     * expression pattern; otherwise throwing an exception with the specified message.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.matchesPattern(&quot;hi&quot;, &quot;[a-z]*&quot;, &quot;%s does not match %s&quot;, &quot;hi&quot; &quot;[a-z]*&quot;);&lt;/pre&gt;
     *
     * &lt;p&gt;The syntax of the pattern is the one used in the {@link Pattern} class.&lt;/p&gt;
     *
     * @param input  the character sequence to validate, not null
     * @param pattern  the regular expression pattern, not null
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @throws IllegalArgumentException if the character sequence does not match the pattern
     * @see #matchesPattern(CharSequence, String)
     *
     * @since 3.0
     */
    public static void matchesPattern(CharSequence input, String pattern, String message, Object... values) {
<span class="fc bfc" id="L873" title="All 2 branches covered.">        if (Pattern.matches(pattern, input) == false) {</span>
<span class="fc" id="L874">            throw new IllegalArgumentException(String.format(message, values));</span>
        }
<span class="fc" id="L876">    }</span>

    // inclusiveBetween
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validate that the specified argument object fall between the two
     * inclusive values specified; otherwise, throws an exception.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.inclusiveBetween(0, 2, 1);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the type of the argument object
     * @param start  the inclusive start value, not null
     * @param end  the inclusive end value, not null
     * @param value  the object to validate, not null
     * @throws IllegalArgumentException if the value falls out of the boundaries
     * @see #inclusiveBetween(Object, Object, Comparable, String, Object...)
     *
     * @since 3.0
     */
    public static &lt;T&gt; void inclusiveBetween(T start, T end, Comparable&lt;T&gt; value) {
<span class="pc bpc" id="L897" title="1 of 4 branches missed.">        if (value.compareTo(start) &lt; 0 || value.compareTo(end) &gt; 0) {</span>
<span class="fc" id="L898">            throw new IllegalArgumentException(String.format(DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end));</span>
        }
<span class="fc" id="L900">    }</span>

    /**
     * &lt;p&gt;Validate that the specified argument object fall between the two
     * inclusive values specified; otherwise, throws an exception with the
     * specified message.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.inclusiveBetween(0, 2, 1, &quot;Not in boundaries&quot;);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the type of the argument object
     * @param start  the inclusive start value, not null
     * @param end  the inclusive end value, not null
     * @param value  the object to validate, not null
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @throws IllegalArgumentException if the value falls out of the boundaries
     * @see #inclusiveBetween(Object, Object, Comparable)
     *
     * @since 3.0
     */
    public static &lt;T&gt; void inclusiveBetween(T start, T end, Comparable&lt;T&gt; value, String message, Object... values) {
<span class="pc bpc" id="L921" title="1 of 4 branches missed.">        if (value.compareTo(start) &lt; 0 || value.compareTo(end) &gt; 0) {</span>
<span class="fc" id="L922">            throw new IllegalArgumentException(String.format(message, values));</span>
        }
<span class="fc" id="L924">    }</span>

    // exclusiveBetween
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validate that the specified argument object fall between the two
     * exclusive values specified; otherwise, throws an exception.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.inclusiveBetween(0, 2, 1);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the type of the argument object
     * @param start  the exclusive start value, not null
     * @param end  the exclusive end value, not null
     * @param value  the object to validate, not null
     * @throws IllegalArgumentException if the value falls out of the boundaries
     * @see #exclusiveBetween(Object, Object, Comparable, String, Object...)
     *
     * @since 3.0
     */
    public static &lt;T&gt; void exclusiveBetween(T start, T end, Comparable&lt;T&gt; value) {
<span class="pc bpc" id="L945" title="1 of 4 branches missed.">        if (value.compareTo(start) &lt;= 0 || value.compareTo(end) &gt;= 0) {</span>
<span class="fc" id="L946">            throw new IllegalArgumentException(String.format(DEFAULT_EXCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end));</span>
        }
<span class="fc" id="L948">    }</span>

    /**
     * &lt;p&gt;Validate that the specified argument object fall between the two
     * exclusive values specified; otherwise, throws an exception with the
     * specified message.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.inclusiveBetween(0, 2, 1, &quot;Not in boundaries&quot;);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the type of the argument object
     * @param start  the exclusive start value, not null
     * @param end  the exclusive end value, not null
     * @param value  the object to validate, not null
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @throws IllegalArgumentException if the value falls out of the boundaries
     * @see #exclusiveBetween(Object, Object, Comparable)
     *
     * @since 3.0
     */
    public static &lt;T&gt; void exclusiveBetween(T start, T end, Comparable&lt;T&gt; value, String message, Object... values) {
<span class="pc bpc" id="L969" title="1 of 4 branches missed.">        if (value.compareTo(start) &lt;= 0 || value.compareTo(end) &gt;= 0) {</span>
<span class="fc" id="L970">            throw new IllegalArgumentException(String.format(message, values));</span>
        }
<span class="fc" id="L972">    }</span>

    // isInstanceOf
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validate that the argument is an instance of the specified class; otherwise
     * throwing an exception. This method is useful when validating according to an arbitrary
     * class&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.isInstanceOf(OkClass.class, object);&lt;/pre&gt;
     *
     * &lt;p&gt;The message of the exception is &amp;quot;The validated object is not an instance of&amp;quot;
     * followed by the name of the class&lt;/p&gt;
     *
     * @param type  the class the object must be validated against, not null
     * @param obj  the object to check, null throws an exception
     * @throws IllegalArgumentException if argument is not of specified class
     * @see #isInstanceOf(Class, Object, String, Object...)
     *
     * @since 3.0
     */
    public static void isInstanceOf(Class&lt;?&gt; type, Object obj) {
<span class="fc bfc" id="L995" title="All 2 branches covered.">        if (type.isInstance(obj) == false) {</span>
<span class="fc" id="L996">            throw new IllegalArgumentException(String.format(DEFAULT_IS_INSTANCE_OF_EX_MESSAGE, type.getName()));</span>
        }
<span class="fc" id="L998">    }</span>

    /**
     * &lt;p&gt;Validate that the argument is an instance of the specified class; otherwise
     * throwing an exception with the specified message. This method is useful when
     * validating according to an arbitrary class&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.isInstanceOf(OkClass.classs, object, &quot;Wrong class, object is of class %s&quot;,
     *   object.getClass().getName());&lt;/pre&gt;
     *
     * @param type  the class the object must be validated against, not null
     * @param obj  the object to check, null throws an exception
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @throws IllegalArgumentException if argument is not of specified class
     * @see #isInstanceOf(Class, Object)
     *
     * @since 3.0
     */
    public static void isInstanceOf(Class&lt;?&gt; type, Object obj, String message, Object... values) {
<span class="fc bfc" id="L1018" title="All 2 branches covered.">        if (type.isInstance(obj) == false) {</span>
<span class="fc" id="L1019">            throw new IllegalArgumentException(String.format(message, values));</span>
        }
<span class="fc" id="L1021">    }</span>

    // isAssignableFrom
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validate that the argument can be converted to the specified class; otherwise
     * throwing an exception with the specified message. This method is useful when
     * validating if there will be no casting errors.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.isAssignableFrom(SuperClass.class, object.getClass());&lt;/pre&gt;
     *
     * &lt;p&gt;The message of the exception is &amp;quot;The validated object can not be converted to the&amp;quot;
     * followed by the name of the class and &amp;quot;class&amp;quot;&lt;/p&gt;
     *
     * @param superType  the class the class must be validated against, not null
     * @param type  the class to check, not null
     * @throws IllegalArgumentException if argument can not be converted to the specified class
     * @see #isAssignableFrom(Class, Class, String, Object...)
     *
     * @since 3.0
     */
    public static void isAssignableFrom(Class&lt;?&gt; superType, Class&lt;?&gt; type) {
<span class="fc bfc" id="L1044" title="All 2 branches covered.">        if (superType.isAssignableFrom(type) == false) {</span>
<span class="fc" id="L1045">            throw new IllegalArgumentException(String.format(DEFAULT_IS_ASSIGNABLE_EX_MESSAGE, superType.getName()));</span>
        }
<span class="fc" id="L1047">    }</span>

    /**
     * &lt;p&gt;Validate that the argument can be converted to the specified class; otherwise
     * throwing an exception. This method is useful when validating if there will be no
     * casting errors.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.isAssignableFrom(SuperClass.class, object.getClass());&lt;/pre&gt;
     *
     * &lt;p&gt;The message of the exception is &amp;quot;The validated object can not be converted to the&amp;quot;
     * followed by the name of the class and &amp;quot;class&amp;quot;&lt;/p&gt;
     *
     * @param superType  the class the class must be validated against, not null
     * @param type  the class to check, not null
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @throws IllegalArgumentException if argument can not be converted to the specified class
     * @see #isAssignableFrom(Class, Class)
     */
    public static void isAssignableFrom(Class&lt;?&gt; superType, Class&lt;?&gt; type, String message, Object... values) {
<span class="fc bfc" id="L1067" title="All 2 branches covered.">        if (superType.isAssignableFrom(type) == false) {</span>
<span class="fc" id="L1068">            throw new IllegalArgumentException(String.format(message, values));</span>
        }
<span class="fc" id="L1070">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>