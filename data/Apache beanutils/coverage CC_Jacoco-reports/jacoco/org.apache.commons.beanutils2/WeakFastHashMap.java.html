<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WeakFastHashMap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons BeanUtils</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.beanutils2</a> &gt; <span class="el_source">WeakFastHashMap.java</span></div><h1>WeakFastHashMap.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.beanutils2;

import java.util.Collection;
import java.util.ConcurrentModificationException;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;

/**
 * &lt;p&gt;A customized implementation of &lt;code&gt;java.util.HashMap&lt;/code&gt; designed
 * to operate in a multithreaded environment where the large majority of
 * method calls are read-only, instead of structural changes.  When operating
 * in &quot;fast&quot; mode, read calls are non-synchronized and write calls perform the
 * following steps:&lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;Clone the existing collection
 * &lt;li&gt;Perform the modification on the clone
 * &lt;li&gt;Replace the existing collection with the (modified) clone
 * &lt;/ul&gt;
 * &lt;p&gt;When first created, objects of this class default to &quot;slow&quot; mode, where
 * all accesses of any type are synchronized but no cloning takes place.  This
 * is appropriate for initially populating the collection, followed by a switch
 * to &quot;fast&quot; mode (by calling &lt;code&gt;setFast(true)&lt;/code&gt;) after initialization
 * is complete.&lt;/p&gt;
 *
 * &lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: If you are creating and accessing a
 * &lt;code&gt;HashMap&lt;/code&gt; only within a single thread, you should use
 * &lt;code&gt;java.util.HashMap&lt;/code&gt; directly (with no synchronization), for
 * maximum performance.&lt;/p&gt;
 *
 * &lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: &lt;i&gt;This class is not cross-platform.
 * Using it may cause unexpected failures on some architectures.&lt;/i&gt;
 * It suffers from the same problems as the double-checked locking idiom.
 * In particular, the instruction that clones the internal collection and the
 * instruction that sets the internal reference to the clone can be executed
 * or perceived out-of-order.  This means that any read operation might fail
 * unexpectedly, as it may be reading the state of the internal collection
 * before the internal collection is fully formed.
 * For more information on the double-checked locking idiom, see the
 * &lt;a href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html&quot;&gt;
 * Double-Checked Locking Idiom Is Broken Declaration&lt;/a&gt;.&lt;/p&gt;
 *
 * @since Commons Collections 1.0
 * @version $Id$
 */
public class WeakFastHashMap&lt;K, V&gt; extends HashMap&lt;K, V&gt; {

    private static final long serialVersionUID = 1L;

    /**
     * The underlying map we are managing.
     */
<span class="pc" id="L71">    private Map&lt;K, V&gt; map = null;</span>

    /**
     * Are we currently operating in &quot;fast&quot; mode?
     */
<span class="pc" id="L76">    private boolean fast = false;</span>

    // Constructors
    // ----------------------------------------------------------------------

    /**
     * Construct an empty map.
     */
    public WeakFastHashMap() {
<span class="fc" id="L85">        super();</span>
<span class="fc" id="L86">        this.map = createMap();</span>
<span class="fc" id="L87">    }</span>

    /**
     * Construct an empty map with the specified capacity.
     *
     * @param capacity  the initial capacity of the empty map
     */
    public WeakFastHashMap(final int capacity) {
<span class="nc" id="L95">        super();</span>
<span class="nc" id="L96">        this.map = createMap(capacity);</span>
<span class="nc" id="L97">    }</span>

    /**
     * Construct an empty map with the specified capacity and load factor.
     *
     * @param capacity  the initial capacity of the empty map
     * @param factor  the load factor of the new map
     */
    public WeakFastHashMap(final int capacity, final float factor) {
<span class="nc" id="L106">        super();</span>
<span class="nc" id="L107">        this.map = createMap(capacity, factor);</span>
<span class="nc" id="L108">    }</span>

    /**
     * Construct a new map with the same mappings as the specified map.
     *
     * @param map  the map whose mappings are to be copied
     */
    public WeakFastHashMap(final Map&lt;? extends K, ? extends V&gt; map) {
<span class="nc" id="L116">        super();</span>
<span class="nc" id="L117">        this.map = createMap(map);</span>
<span class="nc" id="L118">    }</span>


    // Property access
    // ----------------------------------------------------------------------

    /**
     *  Returns true if this map is operating in fast mode.
     *
     *  @return true if this map is operating in fast mode
     */
    public boolean getFast() {
<span class="nc" id="L130">        return this.fast;</span>
    }

    /**
     *  Sets whether this map is operating in fast mode.
     *
     *  @param fast true if this map should operate in fast mode
     */
    public void setFast(final boolean fast) {
<span class="fc" id="L139">        this.fast = fast;</span>
<span class="fc" id="L140">    }</span>


    // Map access
    // ----------------------------------------------------------------------
    // These methods can forward straight to the wrapped Map in 'fast' mode.
    // (because they are query methods)

    /**
     * Return the value to which this map maps the specified key.  Returns
     * &lt;code&gt;null&lt;/code&gt; if the map contains no mapping for this key, or if
     * there is a mapping with a value of &lt;code&gt;null&lt;/code&gt;.  Use the
     * &lt;code&gt;containsKey()&lt;/code&gt; method to disambiguate these cases.
     *
     * @param key  the key whose value is to be returned
     * @return the value mapped to that key, or null
     */
    @Override
    public V get(final Object key) {
<span class="fc bfc" id="L159" title="All 2 branches covered.">        if (fast) {</span>
<span class="fc" id="L160">            return map.get(key);</span>
        }
<span class="fc" id="L162">        synchronized (map) {</span>
<span class="fc" id="L163">            return map.get(key);</span>
<span class="nc" id="L164">        }</span>
    }

    /**
     * Return the number of key-value mappings in this map.
     *
     * @return the current size of the map
     */
    @Override
    public int size() {
<span class="nc bnc" id="L174" title="All 2 branches missed.">        if (fast) {</span>
<span class="nc" id="L175">            return map.size();</span>
        }
<span class="nc" id="L177">        synchronized (map) {</span>
<span class="nc" id="L178">            return map.size();</span>
<span class="nc" id="L179">        }</span>
    }

    /**
     * Return &lt;code&gt;true&lt;/code&gt; if this map contains no mappings.
     *
     * @return is the map currently empty
     */
    @Override
    public boolean isEmpty() {
<span class="nc bnc" id="L189" title="All 2 branches missed.">        if (fast) {</span>
<span class="nc" id="L190">            return map.isEmpty();</span>
        }
<span class="nc" id="L192">        synchronized (map) {</span>
<span class="nc" id="L193">            return map.isEmpty();</span>
<span class="nc" id="L194">        }</span>
    }

    /**
     * Return &lt;code&gt;true&lt;/code&gt; if this map contains a mapping for the
     * specified key.
     *
     * @param key  the key to be searched for
     * @return true if the map contains the key
     */
    @Override
    public boolean containsKey(final Object key) {
<span class="nc bnc" id="L206" title="All 2 branches missed.">        if (fast) {</span>
<span class="nc" id="L207">            return map.containsKey(key);</span>
        }
<span class="nc" id="L209">        synchronized (map) {</span>
<span class="nc" id="L210">            return map.containsKey(key);</span>
<span class="nc" id="L211">        }</span>
    }

    /**
     * Return &lt;code&gt;true&lt;/code&gt; if this map contains one or more keys mapping
     * to the specified value.
     *
     * @param value  the value to be searched for
     * @return true if the map contains the value
     */
    @Override
    public boolean containsValue(final Object value) {
<span class="nc bnc" id="L223" title="All 2 branches missed.">        if (fast) {</span>
<span class="nc" id="L224">            return map.containsValue(value);</span>
        }
<span class="nc" id="L226">        synchronized (map) {</span>
<span class="nc" id="L227">            return map.containsValue(value);</span>
<span class="nc" id="L228">        }</span>
    }

    // Map modification
    // ----------------------------------------------------------------------
    // These methods perform special behaviour in 'fast' mode.
    // The map is cloned, updated and then assigned back.
    // See the comments at the top as to why this won't always work.

    /**
     * Associate the specified value with the specified key in this map.
     * If the map previously contained a mapping for this key, the old
     * value is replaced and returned.
     *
     * @param key  the key with which the value is to be associated
     * @param value  the value to be associated with this key
     * @return the value previously mapped to the key, or null
     */
    @Override
    public V put(final K key, final V value) {
<span class="fc bfc" id="L248" title="All 2 branches covered.">        if (fast) {</span>
<span class="fc" id="L249">            synchronized (this) {</span>
<span class="fc" id="L250">                final Map&lt;K, V&gt; temp = cloneMap(map);</span>
<span class="fc" id="L251">                final V result = temp.put(key, value);</span>
<span class="fc" id="L252">                map = temp;</span>
<span class="fc" id="L253">                return result;</span>
<span class="nc" id="L254">            }</span>
        }
<span class="fc" id="L256">        synchronized (map) {</span>
<span class="fc" id="L257">            return map.put(key, value);</span>
<span class="nc" id="L258">        }</span>
    }

    /**
     * Copy all of the mappings from the specified map to this one, replacing
     * any mappings with the same keys.
     *
     * @param in  the map whose mappings are to be copied
     */
    @Override
    public void putAll(final Map&lt;? extends K, ? extends V&gt; in) {
<span class="nc bnc" id="L269" title="All 2 branches missed.">        if (fast) {</span>
<span class="nc" id="L270">            synchronized (this) {</span>
<span class="nc" id="L271">                final Map&lt;K, V&gt; temp =  cloneMap(map);</span>
<span class="nc" id="L272">                temp.putAll(in);</span>
<span class="nc" id="L273">                map = temp;</span>
<span class="nc" id="L274">            }</span>
        } else {
<span class="nc" id="L276">            synchronized (map) {</span>
<span class="nc" id="L277">                map.putAll(in);</span>
<span class="nc" id="L278">            }</span>
        }
<span class="nc" id="L280">    }</span>

    /**
     * Remove any mapping for this key, and return any previously
     * mapped value.
     *
     * @param key  the key whose mapping is to be removed
     * @return the value removed, or null
     */
    @Override
    public V remove(final Object key) {
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">        if (fast) {</span>
<span class="fc" id="L292">            synchronized (this) {</span>
<span class="fc" id="L293">                final Map&lt;K, V&gt; temp = cloneMap(map);</span>
<span class="fc" id="L294">                final V result = temp.remove(key);</span>
<span class="fc" id="L295">                map = temp;</span>
<span class="fc" id="L296">                return result;</span>
<span class="nc" id="L297">            }</span>
        }
<span class="nc" id="L299">        synchronized (map) {</span>
<span class="nc" id="L300">            return map.remove(key);</span>
<span class="nc" id="L301">        }</span>
    }

    /**
     * Remove all mappings from this map.
     */
    @Override
    public void clear() {
<span class="fc bfc" id="L309" title="All 2 branches covered.">        if (fast) {</span>
<span class="fc" id="L310">            synchronized (this) {</span>
<span class="fc" id="L311">                map = createMap();</span>
<span class="pc" id="L312">            }</span>
        } else {
<span class="fc" id="L314">            synchronized (map) {</span>
<span class="fc" id="L315">                map.clear();</span>
<span class="pc" id="L316">            }</span>
        }
<span class="fc" id="L318">    }</span>

    // Basic object methods
    // ----------------------------------------------------------------------

    /**
     * Compare the specified object with this list for equality.  This
     * implementation uses exactly the code that is used to define the
     * list equals function in the documentation for the
     * &lt;code&gt;Map.equals&lt;/code&gt; method.
     *
     * @param o  the object to be compared to this list
     * @return true if the two maps are equal
     */
    @Override
    public boolean equals(final Object o) {
        // Simple tests that require no synchronization
<span class="nc bnc" id="L335" title="All 2 branches missed.">        if (o == this) {</span>
<span class="nc" id="L336">            return true;</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">        } else if (!(o instanceof Map)) {</span>
<span class="nc" id="L338">            return false;</span>
        }
<span class="nc" id="L340">        final Map&lt;?, ?&gt; mo = (Map&lt;?, ?&gt;) o;</span>

        // Compare the two maps for equality
<span class="nc bnc" id="L343" title="All 2 branches missed.">        if (fast) {</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">            if (mo.size() != map.size()) {</span>
<span class="nc" id="L345">                return false;</span>
            }
<span class="nc bnc" id="L347" title="All 2 branches missed.">            for (final Map.Entry&lt;K, V&gt; e : map.entrySet()) {</span>
<span class="nc" id="L348">                final K key = e.getKey();</span>
<span class="nc" id="L349">                final V value = e.getValue();</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">                if (value == null) {</span>
<span class="nc bnc" id="L351" title="All 4 branches missed.">                    if (!(mo.get(key) == null &amp;&amp; mo.containsKey(key))) {</span>
<span class="nc" id="L352">                        return false;</span>
                    }
                } else {
<span class="nc bnc" id="L355" title="All 2 branches missed.">                    if (!value.equals(mo.get(key))) {</span>
<span class="nc" id="L356">                        return false;</span>
                    }
                }
<span class="nc" id="L359">            }</span>
<span class="nc" id="L360">            return true;</span>

        }
<span class="nc" id="L363">        synchronized (map) {</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">            if (mo.size() != map.size()) {</span>
<span class="nc" id="L365">                return false;</span>
            }
<span class="nc bnc" id="L367" title="All 2 branches missed.">            for (final Map.Entry&lt;K, V&gt; e : map.entrySet()) {</span>
<span class="nc" id="L368">                final K key = e.getKey();</span>
<span class="nc" id="L369">                final V value = e.getValue();</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">                if (value == null) {</span>
<span class="nc bnc" id="L371" title="All 4 branches missed.">                    if (!(mo.get(key) == null &amp;&amp; mo.containsKey(key))) {</span>
<span class="nc" id="L372">                        return false;</span>
                    }
                } else {
<span class="nc bnc" id="L375" title="All 2 branches missed.">                    if (!value.equals(mo.get(key))) {</span>
<span class="nc" id="L376">                        return false;</span>
                    }
                }
<span class="nc" id="L379">            }</span>
<span class="nc" id="L380">            return true;</span>
<span class="nc" id="L381">        }</span>
    }

    /**
     * Return the hash code value for this map.  This implementation uses
     * exactly the code that is used to define the list hash function in the
     * documentation for the &lt;code&gt;Map.hashCode&lt;/code&gt; method.
     *
     * @return suitable integer hash code
     */
    @Override
    public int hashCode() {
<span class="nc bnc" id="L393" title="All 2 branches missed.">        if (fast) {</span>
<span class="nc" id="L394">            int h = 0;</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">            for (final Map.Entry&lt;K, V&gt; e : map.entrySet()) {</span>
<span class="nc" id="L396">                h += e.hashCode();</span>
<span class="nc" id="L397">            }</span>
<span class="nc" id="L398">            return h;</span>
        }
<span class="nc" id="L400">        synchronized (map) {</span>
<span class="nc" id="L401">            int h = 0;</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">            for (final Map.Entry&lt;K, V&gt; e : map.entrySet()) {</span>
<span class="nc" id="L403">                h += e.hashCode();</span>
<span class="nc" id="L404">            }</span>
<span class="nc" id="L405">            return h;</span>
<span class="nc" id="L406">        }</span>
    }

    /**
     * Return a shallow copy of this &lt;code&gt;FastHashMap&lt;/code&gt; instance.
     * The keys and values themselves are not copied.
     *
     * @return a clone of this map
     */
    @Override
    public Object clone() {
<span class="nc" id="L417">        WeakFastHashMap&lt;K, V&gt; results = null;</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">        if (fast) {</span>
<span class="nc" id="L419">            results = new WeakFastHashMap&lt;&gt;(map);</span>
        } else {
<span class="nc" id="L421">            synchronized (map) {</span>
<span class="nc" id="L422">                results = new WeakFastHashMap&lt;&gt;(map);</span>
<span class="nc" id="L423">            }</span>
        }
<span class="nc" id="L425">        results.setFast(getFast());</span>
<span class="nc" id="L426">        return results;</span>
    }

    // Map views
    // ----------------------------------------------------------------------

    /**
     * Return a collection view of the mappings contained in this map.  Each
     * element in the returned collection is a &lt;code&gt;Map.Entry&lt;/code&gt;.
     * @return the set of map Map entries
     */
    @Override
    public Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() {
<span class="nc" id="L439">        return new EntrySet();</span>
    }

    /**
     * Return a set view of the keys contained in this map.
     * @return the set of the Map's keys
     */
    @Override
    public Set&lt;K&gt; keySet() {
<span class="nc" id="L448">        return new KeySet();</span>
    }

    /**
     * Return a collection view of the values contained in this map.
     * @return the set of the Map's values
     */
    @Override
    public Collection&lt;V&gt; values() {
<span class="nc" id="L457">        return new Values();</span>
    }

    // Abstractions on Map creations (for subclasses such as WeakFastHashMap)
    // ----------------------------------------------------------------------

    protected Map&lt;K, V&gt; createMap() {
<span class="fc" id="L464">        return new WeakHashMap&lt;&gt;();</span>
    }

    protected Map&lt;K, V&gt; createMap(final int capacity) {
<span class="nc" id="L468">        return new WeakHashMap&lt;&gt;(capacity);</span>
    }

    protected Map&lt;K, V&gt; createMap(final int capacity, final float factor) {
<span class="nc" id="L472">        return new WeakHashMap&lt;&gt;(capacity, factor);</span>
    }

    protected Map&lt;K, V&gt; createMap(final Map&lt;? extends K, ? extends V&gt; map) {
<span class="fc" id="L476">        return new WeakHashMap&lt;&gt;(map);</span>
    }

    protected Map&lt;K, V&gt; cloneMap(final Map&lt;? extends K, ? extends V&gt; map) {
<span class="fc" id="L480">        return createMap(map);</span>
    }

    // Map view inner classes
    // ----------------------------------------------------------------------

    /**
     * Abstract collection implementation shared by keySet(), values() and entrySet().
     *
     * @param &lt;E&gt; the element type
     */
    private abstract class CollectionView&lt;E&gt; implements Collection&lt;E&gt; {

<span class="nc" id="L493">        public CollectionView() {</span>
<span class="nc" id="L494">        }</span>

        protected abstract Collection&lt;E&gt; get(Map&lt;K, V&gt; map);
        protected abstract E iteratorNext(Map.Entry&lt;K, V&gt; entry);


        @Override
        public void clear() {
<span class="nc bnc" id="L502" title="All 2 branches missed.">            if (fast) {</span>
<span class="nc" id="L503">                synchronized (WeakFastHashMap.this) {</span>
<span class="nc" id="L504">                    map = createMap();</span>
<span class="nc" id="L505">                }</span>
            } else {
<span class="nc" id="L507">                synchronized (map) {</span>
<span class="nc" id="L508">                    get(map).clear();</span>
<span class="nc" id="L509">                }</span>
            }
<span class="nc" id="L511">        }</span>

        @Override
        public boolean remove(final Object o) {
<span class="nc bnc" id="L515" title="All 2 branches missed.">            if (fast) {</span>
<span class="nc" id="L516">                synchronized (WeakFastHashMap.this) {</span>
<span class="nc" id="L517">                    final Map&lt;K, V&gt; temp = cloneMap(map);</span>
<span class="nc" id="L518">                    final boolean r = get(temp).remove(o);</span>
<span class="nc" id="L519">                    map = temp;</span>
<span class="nc" id="L520">                    return r;</span>
<span class="nc" id="L521">                }</span>
            }
<span class="nc" id="L523">            synchronized (map) {</span>
<span class="nc" id="L524">                return get(map).remove(o);</span>
<span class="nc" id="L525">            }</span>
        }

        @Override
        public boolean removeAll(final Collection&lt;?&gt; o) {
<span class="nc bnc" id="L530" title="All 2 branches missed.">            if (fast) {</span>
<span class="nc" id="L531">                synchronized (WeakFastHashMap.this) {</span>
<span class="nc" id="L532">                    final Map&lt;K, V&gt; temp = cloneMap(map);</span>
<span class="nc" id="L533">                    final boolean r = get(temp).removeAll(o);</span>
<span class="nc" id="L534">                    map = temp;</span>
<span class="nc" id="L535">                    return r;</span>
<span class="nc" id="L536">                }</span>
            }
<span class="nc" id="L538">            synchronized (map) {</span>
<span class="nc" id="L539">                return get(map).removeAll(o);</span>
<span class="nc" id="L540">            }</span>
        }

        @Override
        public boolean retainAll(final Collection&lt;?&gt; o) {
<span class="nc bnc" id="L545" title="All 2 branches missed.">            if (fast) {</span>
<span class="nc" id="L546">                synchronized (WeakFastHashMap.this) {</span>
<span class="nc" id="L547">                    final Map&lt;K, V&gt; temp = cloneMap(map);</span>
<span class="nc" id="L548">                    final boolean r = get(temp).retainAll(o);</span>
<span class="nc" id="L549">                    map = temp;</span>
<span class="nc" id="L550">                    return r;</span>
<span class="nc" id="L551">                }</span>
            }
<span class="nc" id="L553">            synchronized (map) {</span>
<span class="nc" id="L554">                return get(map).retainAll(o);</span>
<span class="nc" id="L555">            }</span>
        }

        @Override
        public int size() {
<span class="nc bnc" id="L560" title="All 2 branches missed.">            if (fast) {</span>
<span class="nc" id="L561">                return get(map).size();</span>
            }
<span class="nc" id="L563">            synchronized (map) {</span>
<span class="nc" id="L564">                return get(map).size();</span>
<span class="nc" id="L565">            }</span>
        }


        @Override
        public boolean isEmpty() {
<span class="nc bnc" id="L571" title="All 2 branches missed.">            if (fast) {</span>
<span class="nc" id="L572">                return get(map).isEmpty();</span>
            }
<span class="nc" id="L574">            synchronized (map) {</span>
<span class="nc" id="L575">                return get(map).isEmpty();</span>
<span class="nc" id="L576">            }</span>
        }

        @Override
        public boolean contains(final Object o) {
<span class="nc bnc" id="L581" title="All 2 branches missed.">            if (fast) {</span>
<span class="nc" id="L582">                return get(map).contains(o);</span>
            }
<span class="nc" id="L584">            synchronized (map) {</span>
<span class="nc" id="L585">                return get(map).contains(o);</span>
<span class="nc" id="L586">            }</span>
        }

        @Override
        public boolean containsAll(final Collection&lt;?&gt; o) {
<span class="nc bnc" id="L591" title="All 2 branches missed.">            if (fast) {</span>
<span class="nc" id="L592">                return get(map).containsAll(o);</span>
            }
<span class="nc" id="L594">            synchronized (map) {</span>
<span class="nc" id="L595">                return get(map).containsAll(o);</span>
<span class="nc" id="L596">            }</span>
        }

        @Override
        public &lt;T&gt; T[] toArray(final T[] o) {
<span class="nc bnc" id="L601" title="All 2 branches missed.">            if (fast) {</span>
<span class="nc" id="L602">                return get(map).toArray(o);</span>
            }
<span class="nc" id="L604">            synchronized (map) {</span>
<span class="nc" id="L605">                return get(map).toArray(o);</span>
<span class="nc" id="L606">            }</span>
        }

        @Override
        public Object[] toArray() {
<span class="nc bnc" id="L611" title="All 2 branches missed.">            if (fast) {</span>
<span class="nc" id="L612">                return get(map).toArray();</span>
            }
<span class="nc" id="L614">            synchronized (map) {</span>
<span class="nc" id="L615">                return get(map).toArray();</span>
<span class="nc" id="L616">            }</span>
        }


        @Override
        public boolean equals(final Object o) {
<span class="nc bnc" id="L622" title="All 2 branches missed.">            if (o == this) {</span>
<span class="nc" id="L623">                return true;</span>
            }
<span class="nc bnc" id="L625" title="All 2 branches missed.">            if (fast) {</span>
<span class="nc" id="L626">                return get(map).equals(o);</span>
            }
<span class="nc" id="L628">            synchronized (map) {</span>
<span class="nc" id="L629">                return get(map).equals(o);</span>
<span class="nc" id="L630">            }</span>
        }

        @Override
        public int hashCode() {
<span class="nc bnc" id="L635" title="All 2 branches missed.">            if (fast) {</span>
<span class="nc" id="L636">                return get(map).hashCode();</span>
            }
<span class="nc" id="L638">            synchronized (map) {</span>
<span class="nc" id="L639">                return get(map).hashCode();</span>
<span class="nc" id="L640">            }</span>
        }

        @Override
        public boolean add(final E o) {
<span class="nc" id="L645">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public boolean addAll(final Collection&lt;? extends E&gt; c) {
<span class="nc" id="L650">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public Iterator&lt;E&gt; iterator() {
<span class="nc" id="L655">            return new CollectionViewIterator();</span>
        }

        private class CollectionViewIterator implements Iterator&lt;E&gt; {

            private Map&lt;K, V&gt; expected;
<span class="nc" id="L661">            private Map.Entry&lt;K, V&gt; lastReturned = null;</span>
            private final Iterator&lt;Map.Entry&lt;K, V&gt;&gt; iterator;

<span class="nc" id="L664">            public CollectionViewIterator() {</span>
<span class="nc" id="L665">                this.expected = map;</span>
<span class="nc" id="L666">                this.iterator = expected.entrySet().iterator();</span>
<span class="nc" id="L667">            }</span>

            @Override
            public boolean hasNext() {
<span class="nc bnc" id="L671" title="All 2 branches missed.">                if (expected != map) {</span>
<span class="nc" id="L672">                    throw new ConcurrentModificationException();</span>
                }
<span class="nc" id="L674">                return iterator.hasNext();</span>
            }

            @Override
            public E next() {
<span class="nc bnc" id="L679" title="All 2 branches missed.">                if (expected != map) {</span>
<span class="nc" id="L680">                    throw new ConcurrentModificationException();</span>
                }
<span class="nc" id="L682">                lastReturned = iterator.next();</span>
<span class="nc" id="L683">                return iteratorNext(lastReturned);</span>
            }

            @Override
            public void remove() {
<span class="nc bnc" id="L688" title="All 2 branches missed.">                if (lastReturned == null) {</span>
<span class="nc" id="L689">                    throw new IllegalStateException();</span>
                }
<span class="nc bnc" id="L691" title="All 2 branches missed.">                if (fast) {</span>
<span class="nc" id="L692">                    synchronized (WeakFastHashMap.this) {</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">                        if (expected != map) {</span>
<span class="nc" id="L694">                            throw new ConcurrentModificationException();</span>
                        }
<span class="nc" id="L696">                        WeakFastHashMap.this.remove(lastReturned.getKey());</span>
<span class="nc" id="L697">                        lastReturned = null;</span>
<span class="nc" id="L698">                        expected = map;</span>
<span class="nc" id="L699">                    }</span>
                } else {
<span class="nc" id="L701">                    iterator.remove();</span>
<span class="nc" id="L702">                    lastReturned = null;</span>
                }
<span class="nc" id="L704">            }</span>
        }
    }

    /**
     * Set implementation over the keys of the FastHashMap
     */
<span class="nc" id="L711">    private class KeySet extends CollectionView&lt;K&gt; implements Set&lt;K&gt; {</span>

        @Override
        protected Collection&lt;K&gt; get(final Map&lt;K, V&gt; map) {
<span class="nc" id="L715">            return map.keySet();</span>
        }

        @Override
        protected K iteratorNext(final Map.Entry&lt;K, V&gt; entry) {
<span class="nc" id="L720">            return entry.getKey();</span>
        }

    }

    /**
     * Collection implementation over the values of the FastHashMap
     */
<span class="nc" id="L728">    private class Values extends CollectionView&lt;V&gt; {</span>

        @Override
        protected Collection&lt;V&gt; get(final Map&lt;K, V&gt; map) {
<span class="nc" id="L732">            return map.values();</span>
        }

        @Override
        protected V iteratorNext(final Map.Entry&lt;K, V&gt; entry) {
<span class="nc" id="L737">            return entry.getValue();</span>
        }
    }

    /**
     * Set implementation over the entries of the FastHashMap
     */
<span class="nc" id="L744">    private class EntrySet extends CollectionView&lt;Map.Entry&lt;K, V&gt;&gt; implements Set&lt;Map.Entry&lt;K, V&gt;&gt; {</span>

        @Override
        protected Collection&lt;Map.Entry&lt;K, V&gt;&gt; get(final Map&lt;K, V&gt; map) {
<span class="nc" id="L748">            return map.entrySet();</span>
        }

        @Override
        protected Map.Entry&lt;K, V&gt; iteratorNext(final Map.Entry&lt;K, V&gt; entry) {
<span class="nc" id="L753">            return entry;</span>
        }

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>