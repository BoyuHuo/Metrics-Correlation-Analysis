<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConstructorUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons BeanUtils</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.beanutils2</a> &gt; <span class="el_source">ConstructorUtils.java</span></div><h1>ConstructorUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.beanutils2;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;

/**
 * &lt;p&gt; Utility reflection methods focussed on constructors, modelled after {@link MethodUtils}. &lt;/p&gt;
 *
 * &lt;h3&gt;Known Limitations&lt;/h3&gt;
 * &lt;h4&gt;Accessing Public Constructors In A Default Access Superclass&lt;/h4&gt;
 * &lt;p&gt;There is an issue when invoking public constructors contained in a default access superclass.
 * Reflection locates these constructors fine and correctly assigns them as public.
 * However, an &lt;code&gt;IllegalAccessException&lt;/code&gt; is thrown if the constructors is invoked.&lt;/p&gt;
 *
 * &lt;p&gt;&lt;code&gt;ConstructorUtils&lt;/code&gt; contains a workaround for this situation.
 * It will attempt to call &lt;code&gt;setAccessible&lt;/code&gt; on this constructor.
 * If this call succeeds, then the method can be invoked as normal.
 * This call will only succeed when the application has sufficient security privilages.
 * If this call fails then a warning will be logged and the method may fail.&lt;/p&gt;
 *
 * @version $Id$
 */
<span class="nc" id="L41">public class ConstructorUtils {</span>

    // --------------------------------------------------------- Private Members
    /** An empty class array */
<span class="fc" id="L45">    private static final Class&lt;?&gt;[] EMPTY_CLASS_PARAMETERS = new Class&lt;?&gt;[0];</span>
    /** An empty object array */
<span class="fc" id="L47">    private static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];</span>

    // --------------------------------------------------------- Public Methods

    /**
     * &lt;p&gt;Convenience method returning new instance of &lt;code&gt;klazz&lt;/code&gt; using a single argument constructor.
     * The formal parameter type is inferred from the actual values of &lt;code&gt;arg&lt;/code&gt;.
     * See {@link #invokeExactConstructor(Class, Object[], Class[])} for more details.&lt;/p&gt;
     *
     * &lt;p&gt;The signatures should be assignment compatible.&lt;/p&gt;
     *
     * @param &lt;T&gt; the type of the object to be constructed
     * @param klass the class to be constructed.
     * @param arg the actual argument. May be null (this will result in calling the default constructor).
     * @return new instance of &lt;code&gt;klazz&lt;/code&gt;
     *
     * @throws NoSuchMethodException If the constructor cannot be found
     * @throws IllegalAccessException If an error occurs accessing the constructor
     * @throws InvocationTargetException If an error occurs invoking the constructor
     * @throws InstantiationException If an error occurs instantiating the class
     *
     * @see #invokeConstructor(java.lang.Class, java.lang.Object[], java.lang.Class[])
     */
    public static &lt;T&gt; T invokeConstructor(final Class&lt;T&gt; klass, final Object arg)
        throws
            NoSuchMethodException,
            IllegalAccessException,
            InvocationTargetException,
            InstantiationException {

<span class="fc" id="L77">        final Object[] args = toArray(arg);</span>
<span class="fc" id="L78">        return invokeConstructor(klass, args);</span>
    }

    /**
     * &lt;p&gt;Returns new instance of &lt;code&gt;klazz&lt;/code&gt; created using the actual arguments &lt;code&gt;args&lt;/code&gt;.
     * The formal parameter types are inferred from the actual values of &lt;code&gt;args&lt;/code&gt;.
     * See {@link #invokeExactConstructor(Class, Object[], Class[])} for more details.&lt;/p&gt;
     *
     * &lt;p&gt;The signatures should be assignment compatible.&lt;/p&gt;
     *
     * @param &lt;T&gt; the type of the object to be constructed
     * @param klass the class to be constructed.
     * @param args actual argument array. May be null (this will result in calling the default constructor).
     * @return new instance of &lt;code&gt;klazz&lt;/code&gt;
     *
     * @throws NoSuchMethodException If the constructor cannot be found
     * @throws IllegalAccessException If an error occurs accessing the constructor
     * @throws InvocationTargetException If an error occurs invoking the constructor
     * @throws InstantiationException If an error occurs instantiating the class
     *
     * @see #invokeConstructor(java.lang.Class, java.lang.Object[], java.lang.Class[])
     */
    public static &lt;T&gt; T invokeConstructor(final Class&lt;T&gt; klass, Object[] args)
        throws
            NoSuchMethodException,
            IllegalAccessException,
            InvocationTargetException,
            InstantiationException {

<span class="fc bfc" id="L107" title="All 2 branches covered.">        if (null == args) {</span>
<span class="fc" id="L108">            args = EMPTY_OBJECT_ARRAY;</span>
        }
<span class="fc" id="L110">        final int arguments = args.length;</span>
<span class="fc" id="L111">        final Class&lt;?&gt; parameterTypes[] = new Class&lt;?&gt;[arguments];</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">        for (int i = 0; i &lt; arguments; i++) {</span>
<span class="fc" id="L113">            parameterTypes[i] = args[i].getClass();</span>
        }
<span class="fc" id="L115">        return invokeConstructor(klass, args, parameterTypes);</span>
    }

    /**
     * &lt;p&gt;Returns new instance of &lt;code&gt;klazz&lt;/code&gt; created using constructor
     * with signature &lt;code&gt;parameterTypes&lt;/code&gt; and actual arguments &lt;code&gt;args&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;The signatures should be assignment compatible.&lt;/p&gt;
     *
     * @param &lt;T&gt; the type of the object to be constructed
     * @param klass the class to be constructed.
     * @param args actual argument array. May be null (this will result in calling the default constructor).
     * @param parameterTypes parameter types array
     * @return new instance of &lt;code&gt;klazz&lt;/code&gt;
     *
     * @throws NoSuchMethodException if matching constructor cannot be found
     * @throws IllegalAccessException thrown on the constructor's invocation
     * @throws InvocationTargetException thrown on the constructor's invocation
     * @throws InstantiationException thrown on the constructor's invocation
     * @see Constructor#newInstance
     */
    public static &lt;T&gt; T invokeConstructor(
        final Class&lt;T&gt; klass,
        Object[] args,
        Class&lt;?&gt;[] parameterTypes)
        throws
            NoSuchMethodException,
            IllegalAccessException,
            InvocationTargetException,
            InstantiationException {

<span class="pc bpc" id="L146" title="1 of 2 branches missed.">        if (parameterTypes == null) {</span>
<span class="nc" id="L147">            parameterTypes = EMPTY_CLASS_PARAMETERS;</span>
        }
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">        if (args == null) {</span>
<span class="nc" id="L150">            args = EMPTY_OBJECT_ARRAY;</span>
        }

<span class="fc" id="L153">        final Constructor&lt;T&gt; ctor =</span>
<span class="fc" id="L154">            getMatchingAccessibleConstructor(klass, parameterTypes);</span>
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">        if (null == ctor) {</span>
<span class="nc" id="L156">            throw new NoSuchMethodException(</span>
<span class="nc" id="L157">                &quot;No such accessible constructor on object: &quot; + klass.getName());</span>
        }
<span class="fc" id="L159">        return ctor.newInstance(args);</span>
    }


    /**
     * &lt;p&gt;Convenience method returning new instance of &lt;code&gt;klazz&lt;/code&gt; using a single argument constructor.
     * The formal parameter type is inferred from the actual values of &lt;code&gt;arg&lt;/code&gt;.
     * See {@link #invokeExactConstructor(Class, Object[], Class[])} for more details.&lt;/p&gt;
     *
     * &lt;p&gt;The signatures should match exactly.&lt;/p&gt;
     *
     * @param &lt;T&gt; the type of the object to be constructed
     * @param klass the class to be constructed.
     * @param arg the actual argument. May be null (this will result in calling the default constructor).
     * @return new instance of &lt;code&gt;klazz&lt;/code&gt;
     *
     * @throws NoSuchMethodException If the constructor cannot be found
     * @throws IllegalAccessException If an error occurs accessing the constructor
     * @throws InvocationTargetException If an error occurs invoking the constructor
     * @throws InstantiationException If an error occurs instantiating the class
     *
     * @see #invokeExactConstructor(java.lang.Class, java.lang.Object[], java.lang.Class[])
     */
    public static &lt;T&gt; T invokeExactConstructor(final Class&lt;T&gt; klass, final Object arg)
        throws
            NoSuchMethodException,
            IllegalAccessException,
            InvocationTargetException,
            InstantiationException {

<span class="fc" id="L189">        final Object[] args = toArray(arg);</span>
<span class="fc" id="L190">        return invokeExactConstructor(klass, args);</span>
    }

    /**
     * &lt;p&gt;Returns new instance of &lt;code&gt;klazz&lt;/code&gt; created using the actual arguments &lt;code&gt;args&lt;/code&gt;.
     * The formal parameter types are inferred from the actual values of &lt;code&gt;args&lt;/code&gt;.
     * See {@link #invokeExactConstructor(Class, Object[], Class[])} for more details.&lt;/p&gt;
     *
     * &lt;p&gt;The signatures should match exactly.&lt;/p&gt;
     *
     * @param &lt;T&gt; the type of the object to be constructed
     * @param klass the class to be constructed.
     * @param args actual argument array. May be null (this will result in calling the default constructor).
     * @return new instance of &lt;code&gt;klazz&lt;/code&gt;
     *
     * @throws NoSuchMethodException If the constructor cannot be found
     * @throws IllegalAccessException If an error occurs accessing the constructor
     * @throws InvocationTargetException If an error occurs invoking the constructor
     * @throws InstantiationException If an error occurs instantiating the class
     *
     * @see #invokeExactConstructor(java.lang.Class, java.lang.Object[], java.lang.Class[])
     */
    public static &lt;T&gt; T invokeExactConstructor(final Class&lt;T&gt; klass, Object[] args)
        throws
            NoSuchMethodException,
            IllegalAccessException,
            InvocationTargetException,
            InstantiationException {

<span class="fc bfc" id="L219" title="All 2 branches covered.">        if (null == args) {</span>
<span class="fc" id="L220">            args = EMPTY_OBJECT_ARRAY;</span>
        }
<span class="fc" id="L222">        final int arguments = args.length;</span>
<span class="fc" id="L223">        final Class&lt;?&gt; parameterTypes[] = new Class[arguments];</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">        for (int i = 0; i &lt; arguments; i++) {</span>
<span class="fc" id="L225">            parameterTypes[i] = args[i].getClass();</span>
        }
<span class="fc" id="L227">        return invokeExactConstructor(klass, args, parameterTypes);</span>
    }

    /**
     * &lt;p&gt;Returns new instance of &lt;code&gt;klazz&lt;/code&gt; created using constructor
     * with signature &lt;code&gt;parameterTypes&lt;/code&gt; and actual arguments
     * &lt;code&gt;args&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;The signatures should match exactly.&lt;/p&gt;
     *
     * @param &lt;T&gt; the type of the object to be constructed
     * @param klass the class to be constructed.
     * @param args actual argument array. May be null (this will result in calling the default constructor).
     * @param parameterTypes parameter types array
     * @return new instance of &lt;code&gt;klazz&lt;/code&gt;
     *
     * @throws NoSuchMethodException if matching constructor cannot be found
     * @throws IllegalAccessException thrown on the constructor's invocation
     * @throws InvocationTargetException thrown on the constructor's invocation
     * @throws InstantiationException thrown on the constructor's invocation
     * @see Constructor#newInstance
     */
    public static &lt;T&gt; T invokeExactConstructor(
        final Class&lt;T&gt; klass,
        Object[] args,
        Class&lt;?&gt;[] parameterTypes)
        throws
            NoSuchMethodException,
            IllegalAccessException,
            InvocationTargetException,
            InstantiationException {

<span class="pc bpc" id="L259" title="1 of 2 branches missed.">        if (args == null) {</span>
<span class="nc" id="L260">            args = EMPTY_OBJECT_ARRAY;</span>
        }

<span class="pc bpc" id="L263" title="1 of 2 branches missed.">        if (parameterTypes == null) {</span>
<span class="nc" id="L264">            parameterTypes = EMPTY_CLASS_PARAMETERS;</span>
        }

<span class="fc" id="L267">        final Constructor&lt;T&gt; ctor = getAccessibleConstructor(klass, parameterTypes);</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">        if (null == ctor) {</span>
<span class="fc" id="L269">            throw new NoSuchMethodException(</span>
<span class="fc" id="L270">                &quot;No such accessible constructor on object: &quot; + klass.getName());</span>
        }
<span class="fc" id="L272">        return ctor.newInstance(args);</span>
    }

    /**
     * Returns a constructor with single argument.
     * @param &lt;T&gt; the type of the constructor
     * @param klass the class to be constructed
     * @param parameterType The constructor parameter type
     * @return null if matching accessible constructor can not be found.
     * @see Class#getConstructor
     * @see #getAccessibleConstructor(java.lang.reflect.Constructor)
     */
    public static &lt;T&gt; Constructor&lt;T&gt; getAccessibleConstructor(
        final Class&lt;T&gt; klass,
        final Class&lt;?&gt; parameterType) {

<span class="fc" id="L288">        final Class&lt;?&gt;[] parameterTypes = { parameterType };</span>
<span class="fc" id="L289">        return getAccessibleConstructor(klass, parameterTypes);</span>
    }

    /**
     * Returns a constructor given a class and signature.
     * @param &lt;T&gt; the type to be constructed
     * @param klass the class to be constructed
     * @param parameterTypes the parameter array
     * @return null if matching accessible constructor can not be found
     * @see Class#getConstructor
     * @see #getAccessibleConstructor(java.lang.reflect.Constructor)
     */
    public static &lt;T&gt; Constructor&lt;T&gt; getAccessibleConstructor(
        final Class&lt;T&gt; klass,
        final Class&lt;?&gt;[] parameterTypes) {

        try {
<span class="fc" id="L306">            return getAccessibleConstructor(</span>
<span class="fc" id="L307">                klass.getConstructor(parameterTypes));</span>
<span class="fc" id="L308">        } catch (final NoSuchMethodException e) {</span>
<span class="fc" id="L309">            return null;</span>
        }
    }

    /**
     * Returns accessible version of the given constructor.
     * @param &lt;T&gt; the type of the constructor
     * @param ctor prototype constructor object.
     * @return &lt;code&gt;null&lt;/code&gt; if accessible constructor can not be found.
     * @see java.lang.SecurityManager
     */
    public static &lt;T&gt; Constructor&lt;T&gt; getAccessibleConstructor(final Constructor&lt;T&gt; ctor) {

        // Make sure we have a method to check
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">        if (ctor == null) {</span>
<span class="nc" id="L324">            return null;</span>
        }

        // If the requested method is not public we cannot call it
<span class="fc bfc" id="L328" title="All 2 branches covered.">        if (!Modifier.isPublic(ctor.getModifiers())) {</span>
<span class="fc" id="L329">            return null;</span>
        }

        // If the declaring class is public, we are done
<span class="fc" id="L333">        final Class&lt;T&gt; clazz = ctor.getDeclaringClass();</span>
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">        if (Modifier.isPublic(clazz.getModifiers())) {</span>
<span class="fc" id="L335">            return ctor;</span>
        }

        // what else can we do?
<span class="nc" id="L339">        return null;</span>
    }

    private static Object[] toArray(final Object arg) {
<span class="fc" id="L343">        Object[] args = null;</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">        if (arg != null) {</span>
<span class="fc" id="L345">            args = new Object[] { arg };</span>
        }
<span class="fc" id="L347">        return args;</span>
    }

    // -------------------------------------------------------- Private Methods
    /**
     * &lt;p&gt;Find an accessible constructor with compatible parameters.
     * Compatible parameters mean that every method parameter is assignable from
     * the given parameters. In other words, it finds constructor that will take
     * the parameters given.&lt;/p&gt;
     *
     * &lt;p&gt;First it checks if there is constructor matching the exact signature.
     * If no such, all the constructors of the class are tested if their signatures
     * are assignment compatible with the parameter types.
     * The first matching constructor is returned.&lt;/p&gt;
     *
     * @param &lt;T&gt; the type of the class to be inspected
     * @param clazz find constructor for this class
     * @param parameterTypes find method with compatible parameters
     * @return a valid Constructor object. If there's no matching constructor, returns &lt;code&gt;null&lt;/code&gt;.
     */
    private static &lt;T&gt; Constructor&lt;T&gt; getMatchingAccessibleConstructor(
        final Class&lt;T&gt; clazz,
        final Class&lt;?&gt;[] parameterTypes) {
        // see if we can find the method directly
        // most of the time this works and it's much faster
        try {
<span class="fc" id="L373">            final Constructor&lt;T&gt; ctor = clazz.getConstructor(parameterTypes);</span>
            try {
                //
                // XXX Default access superclass workaround
                //
                // When a public class has a default access superclass
                // with public methods, these methods are accessible.
                // Calling them from compiled code works fine.
                //
                // Unfortunately, using reflection to invoke these methods
                // seems to (wrongly) to prevent access even when the method
                // modifer is public.
                //
                // The following workaround solves the problem but will only
                // work from sufficiently privilages code.
                //
                // Better workarounds would be greatfully accepted.
                //
<span class="fc" id="L391">                ctor.setAccessible(true);</span>
<span class="nc" id="L392">            } catch (final SecurityException se) {</span>
                /* SWALLOW, if workaround fails don't fret. */
<span class="fc" id="L394">            }</span>
<span class="fc" id="L395">            return ctor;</span>

<span class="fc" id="L397">        } catch (final NoSuchMethodException e) { /* SWALLOW */</span>
        }

        // search through all methods
<span class="fc" id="L401">        final int paramSize = parameterTypes.length;</span>
<span class="fc" id="L402">        final Constructor&lt;?&gt;[] ctors = clazz.getConstructors();</span>
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">        for (final Constructor&lt;?&gt; ctor2 : ctors) {</span>
            // compare parameters
<span class="fc" id="L405">            final Class&lt;?&gt;[] ctorParams = ctor2.getParameterTypes();</span>
<span class="fc" id="L406">            final int ctorParamSize = ctorParams.length;</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">            if (ctorParamSize == paramSize) {</span>
<span class="fc" id="L408">                boolean match = true;</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">                for (int n = 0; n &lt; ctorParamSize; n++) {</span>
<span class="fc" id="L410">                    if (!MethodUtils</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">                        .isAssignmentCompatible(</span>
                            ctorParams[n],
                            parameterTypes[n])) {
<span class="fc" id="L414">                        match = false;</span>
<span class="fc" id="L415">                        break;</span>
                    }
                }

<span class="fc bfc" id="L419" title="All 2 branches covered.">                if (match) {</span>
                    // get accessible version of method
<span class="fc" id="L421">                    final Constructor&lt;?&gt; ctor = getAccessibleConstructor(ctor2);</span>
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">                    if (ctor != null) {</span>
                        try {
<span class="fc" id="L424">                            ctor.setAccessible(true);</span>
<span class="nc" id="L425">                        } catch (final SecurityException se) {</span>
                            /* Swallow SecurityException
                             * TODO: Why?
                             */
<span class="fc" id="L429">                        }</span>
                        @SuppressWarnings(&quot;unchecked&quot;)
                        final
                        // Class.getConstructors() actually returns constructors
                        // of type T, so it is safe to cast.
<span class="fc" id="L434">                        Constructor&lt;T&gt; typedCtor = (Constructor&lt;T&gt;) ctor;</span>
<span class="fc" id="L435">                        return typedCtor;</span>
                    }
                }
            }
        }

<span class="nc" id="L441">        return null;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>