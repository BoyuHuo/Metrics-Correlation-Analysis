<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JDBCDynaClass.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons BeanUtils</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.beanutils2</a> &gt; <span class="el_source">JDBCDynaClass.java</span></div><h1>JDBCDynaClass.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.beanutils2;

import java.io.Serializable;
import java.sql.Date;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * &lt;p&gt;Provides common logic for JDBC implementations of {@link DynaClass}.&lt;/p&gt;
 *
 * @version $Id$
 */

<span class="fc" id="L38">abstract class JDBCDynaClass implements DynaClass, Serializable {</span>

    private static final long serialVersionUID = 1L;

    // ----------------------------------------------------- Instance Variables

    /**
     * &lt;p&gt;Flag defining whether column names should be lower cased when
     * converted to property names.&lt;/p&gt;
     */
<span class="fc" id="L48">    protected boolean lowerCase = true;</span>

    /**
     * &lt;p&gt;Flag defining whether column names or labels should be used.
     */
    private boolean useColumnLabel;

    /**
     * &lt;p&gt;The set of dynamic properties that are part of this
     * {@link DynaClass}.&lt;/p&gt;
     */
<span class="fc" id="L59">    protected DynaProperty[] properties = null;</span>

    /**
     * &lt;p&gt;The set of dynamic properties that are part of this
     * {@link DynaClass}, keyed by the property name.  Individual descriptor
     * instances will be the same instances as those in the
     * &lt;code&gt;properties&lt;/code&gt; list.&lt;/p&gt;
     */
<span class="fc" id="L67">    protected Map&lt;String, DynaProperty&gt; propertiesMap = new HashMap&lt;&gt;();</span>

    /**
     * Cross Reference for column name --&gt; dyna property name
     * (needed when lowerCase option is true)
     */
    private Map&lt;String, String&gt; columnNameXref;

    // ------------------------------------------------------ DynaClass Methods

    /**
     * &lt;p&gt;Return the name of this DynaClass (analogous to the
     * &lt;code&gt;getName()&lt;/code&gt; method of &lt;code&gt;java.lang.Class&lt;/code&gt;, which
     * allows the same &lt;code&gt;DynaClass&lt;/code&gt; implementation class to support
     * different dynamic classes, with different sets of properties.&lt;/p&gt;
     */
    @Override
    public String getName() {

<span class="fc" id="L86">        return this.getClass().getName();</span>

    }

    /**
     * &lt;p&gt;Return a property descriptor for the specified property, if it
     * exists; otherwise, return &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * @param name Name of the dynamic property for which a descriptor
     *  is requested
     *
     * @throws IllegalArgumentException if no property name is specified
     */
    @Override
    public DynaProperty getDynaProperty(final String name) {

<span class="fc bfc" id="L102" title="All 2 branches covered.">        if (name == null) {</span>
<span class="fc" id="L103">            throw new IllegalArgumentException(&quot;No property name specified&quot;);</span>
        }
<span class="fc" id="L105">        return propertiesMap.get(name);</span>

    }

    /**
     * &lt;p&gt;Return an array of &lt;code&gt;ProperyDescriptors&lt;/code&gt; for the properties
     * currently defined in this DynaClass.  If no properties are defined, a
     * zero-length array will be returned.&lt;/p&gt;
     */
    @Override
    public DynaProperty[] getDynaProperties() {

<span class="fc" id="L117">        return properties;</span>

    }

    /**
     * &lt;p&gt;Instantiate and return a new DynaBean instance, associated
     * with this DynaClass.  &lt;strong&gt;NOTE&lt;/strong&gt; - This operation is not
     * supported, and throws an exception.&lt;/p&gt;
     *
     * @throws IllegalAccessException if the Class or the appropriate
     *  constructor is not accessible
     * @throws InstantiationException if this Class represents an abstract
     *  class, an array class, a primitive type, or void; or if instantiation
     *  fails for some other reason
     */
    @Override
    public DynaBean newInstance()
            throws IllegalAccessException, InstantiationException {

<span class="fc" id="L136">        throw new UnsupportedOperationException(&quot;newInstance() not supported&quot;);</span>

    }

    /**
     * Set whether the column label or name should be used for the property name.
     *
     * @param useColumnLabel true if the column label should be used, otherwise false
     */
    public void setUseColumnLabel(final boolean useColumnLabel) {
<span class="fc" id="L146">        this.useColumnLabel = useColumnLabel;</span>
<span class="fc" id="L147">    }</span>

    /**
     * &lt;p&gt;Loads and returns the &lt;code&gt;Class&lt;/code&gt; of the given name.
     * By default, a load from the thread context class loader is attempted.
     * If there is no such class loader, the class loader used to load this
     * class will be utilized.&lt;/p&gt;
     *
     * @param className The name of the class to load
     * @return The loaded class
     * @throws SQLException if an exception was thrown trying to load
     *  the specified class
     */
    protected Class&lt;?&gt; loadClass(final String className) throws SQLException {

        try {
<span class="fc" id="L163">            ClassLoader cl = Thread.currentThread().getContextClassLoader();</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">            if (cl == null) {</span>
<span class="nc" id="L165">                    cl = this.getClass().getClassLoader();</span>
            }
            // use Class.forName() - see BEANUTILS-327
<span class="fc" id="L168">            return Class.forName(className, false, cl);</span>
<span class="nc" id="L169">        } catch (final Exception e) {</span>
<span class="nc" id="L170">            throw new SQLException(</span>
                    &quot;Cannot load column class '&quot; + className + &quot;': &quot; + e);
        }

    }

    /**
     * &lt;p&gt;Factory method to create a new DynaProperty for the given index
     * into the result set metadata.&lt;/p&gt;
     *
     * @param metadata is the result set metadata
     * @param i is the column index in the metadata
     * @return the newly created DynaProperty instance
     * @throws SQLException If an error occurs accessing the SQL metadata
     */
    protected DynaProperty createDynaProperty(
                                    final ResultSetMetaData metadata,
                                    final int i)
                                    throws SQLException {

<span class="fc" id="L190">        String columnName = null;</span>
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">        if (useColumnLabel) {</span>
<span class="nc" id="L192">            columnName = metadata.getColumnLabel(i);</span>
        }
<span class="pc bpc" id="L194" title="3 of 4 branches missed.">        if (columnName == null || columnName.trim().length() == 0) {</span>
<span class="fc" id="L195">            columnName = metadata.getColumnName(i);</span>
        }
<span class="fc bfc" id="L197" title="All 2 branches covered.">        final String name = lowerCase ? columnName.toLowerCase() : columnName;</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">        if (!name.equals(columnName)) {</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">            if (columnNameXref == null) {</span>
<span class="fc" id="L200">                columnNameXref = new HashMap&lt;&gt;();</span>
            }
<span class="fc" id="L202">            columnNameXref.put(name, columnName);</span>
        }
<span class="fc" id="L204">        String className = null;</span>
        try {
<span class="fc" id="L206">            final int sqlType = metadata.getColumnType(i);</span>
<span class="fc bfc" id="L207" title="All 4 branches covered.">            switch (sqlType) {</span>
                case java.sql.Types.DATE:
<span class="fc" id="L209">                    return new DynaProperty(name, java.sql.Date.class);</span>
                case java.sql.Types.TIMESTAMP:
<span class="fc" id="L211">                    return new DynaProperty(name, java.sql.Timestamp.class);</span>
                case java.sql.Types.TIME:
<span class="fc" id="L213">                    return new DynaProperty(name, java.sql.Time.class);</span>
                default:
<span class="fc" id="L215">                    className = metadata.getColumnClassName(i);</span>
            }
<span class="nc" id="L217">        } catch (final SQLException e) {</span>
            // this is a patch for HsqlDb to ignore exceptions
            // thrown by its metadata implementation
<span class="fc" id="L220">        }</span>

        // Default to Object type if no class name could be retrieved
        // from the metadata
<span class="fc" id="L224">        Class&lt;?&gt; clazz = Object.class;</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">        if (className != null) {</span>
<span class="fc" id="L226">            clazz = loadClass(className);</span>
        }
<span class="fc" id="L228">        return new DynaProperty(name, clazz);</span>

    }

    /**
     * &lt;p&gt;Introspect the metadata associated with our result set, and populate
     * the &lt;code&gt;properties&lt;/code&gt; and &lt;code&gt;propertiesMap&lt;/code&gt; instance
     * variables.&lt;/p&gt;
     *
     * @param resultSet The &lt;code&gt;resultSet&lt;/code&gt; whose metadata is to
     *  be introspected
     *
     * @throws SQLException if an error is encountered processing the
     *  result set metadata
     */
    protected void introspect(final ResultSet resultSet) throws SQLException {

        // Accumulate an ordered list of DynaProperties
<span class="fc" id="L246">        final List&lt;DynaProperty&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L247">        final ResultSetMetaData metadata = resultSet.getMetaData();</span>
<span class="fc" id="L248">        final int n = metadata.getColumnCount();</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">        for (int i = 1; i &lt;= n; i++) { // JDBC is one-relative!</span>
<span class="fc" id="L250">            final DynaProperty dynaProperty = createDynaProperty(metadata, i);</span>
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">            if (dynaProperty != null) {</span>
<span class="fc" id="L252">                    list.add(dynaProperty);</span>
            }
        }

        // Convert this list into the internal data structures we need
<span class="fc" id="L257">        properties =</span>
<span class="fc" id="L258">            list.toArray(new DynaProperty[list.size()]);</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">        for (final DynaProperty propertie : properties) {</span>
<span class="fc" id="L260">            propertiesMap.put(propertie.getName(), propertie);</span>
        }

<span class="fc" id="L263">    }</span>

    /**
     * Get a column value from a {@link ResultSet} for the specified name.
     *
     * @param resultSet The result set
     * @param name The property name
     * @return The value
     * @throws SQLException if an error occurs
     */
    protected Object getObject(final ResultSet resultSet, final String name) throws SQLException {

<span class="fc" id="L275">        final DynaProperty property = getDynaProperty(name);</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">        if (property == null) {</span>
<span class="nc" id="L277">            throw new IllegalArgumentException(&quot;Invalid name '&quot; + name + &quot;'&quot;);</span>
        }
<span class="fc" id="L279">        final String columnName = getColumnName(name);</span>
<span class="fc" id="L280">        final Class&lt;?&gt; type = property.getType();</span>

        // java.sql.Date
<span class="fc bfc" id="L283" title="All 2 branches covered.">        if (type.equals(Date.class)) {</span>
<span class="fc" id="L284">            return resultSet.getDate(columnName);</span>
        }

        // java.sql.Timestamp
<span class="fc bfc" id="L288" title="All 2 branches covered.">        if (type.equals(Timestamp.class)) {</span>
<span class="fc" id="L289">            return resultSet.getTimestamp(columnName);</span>
        }

        // java.sql.Time
<span class="fc bfc" id="L293" title="All 2 branches covered.">        if (type.equals(Time.class)) {</span>
<span class="fc" id="L294">            return resultSet.getTime(columnName);</span>
        }

<span class="fc" id="L297">        return resultSet.getObject(columnName);</span>
    }

    /**
     * Get the table column name for the specified property name.
     *
     * @param name The property name
     * @return The column name (which can be different if the &lt;i&gt;lowerCase&lt;/i&gt;
     * option is used).
     */
    protected String getColumnName(final String name) {
<span class="pc bpc" id="L308" title="1 of 4 branches missed.">        if (columnNameXref != null &amp;&amp; columnNameXref.containsKey(name)) {</span>
<span class="fc" id="L309">            return columnNameXref.get(name);</span>
        }
<span class="fc" id="L311">        return name;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>