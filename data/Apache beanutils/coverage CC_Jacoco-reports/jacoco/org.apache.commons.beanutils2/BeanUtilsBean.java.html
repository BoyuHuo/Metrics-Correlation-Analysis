<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BeanUtilsBean.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons BeanUtils</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.beanutils2</a> &gt; <span class="el_source">BeanUtilsBean.java</span></div><h1>BeanUtilsBean.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package org.apache.commons.beanutils2;


import java.beans.IndexedPropertyDescriptor;
import java.beans.PropertyDescriptor;
import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.beanutils2.expression.Resolver;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;


/**
 * &lt;p&gt;JavaBean property population methods.&lt;/p&gt;
 *
 * &lt;p&gt;This class provides implementations for the utility methods in
 * {@link BeanUtils}.
 * Different instances can be used to isolate caches between classloaders
 * and to vary the value converters registered.&lt;/p&gt;
 *
 * @version $Id$
 * @see BeanUtils
 * @since 1.7
 */

public class BeanUtilsBean {


    // ------------------------------------------------------ Private Class Variables

    /**
     * Contains &lt;code&gt;BeanUtilsBean&lt;/code&gt; instances indexed by context classloader.
     */
    private static final ContextClassLoaderLocal&lt;BeanUtilsBean&gt;
<span class="fc" id="L60">            BEANS_BY_CLASSLOADER = new ContextClassLoaderLocal&lt;BeanUtilsBean&gt;() {</span>
                        // Creates the default instance used when the context classloader is unavailable
                        @Override
                        protected BeanUtilsBean initialValue() {
<span class="fc" id="L64">                            return new BeanUtilsBean();</span>
                        }
                    };

    /**
     * Gets the instance which provides the functionality for {@link BeanUtils}.
     * This is a pseudo-singleton - an single instance is provided per (thread) context classloader.
     * This mechanism provides isolation for web apps deployed in the same container.
     *
     * @return The (pseudo-singleton) BeanUtils bean instance
     */
    public static BeanUtilsBean getInstance() {
<span class="fc" id="L76">        return BEANS_BY_CLASSLOADER.get();</span>
    }

    /**
     * Sets the instance which provides the functionality for {@link BeanUtils}.
     * This is a pseudo-singleton - an single instance is provided per (thread) context classloader.
     * This mechanism provides isolation for web apps deployed in the same container.
     *
     * @param newInstance The (pseudo-singleton) BeanUtils bean instance
     */
    public static void setInstance(final BeanUtilsBean newInstance) {
<span class="fc" id="L87">        BEANS_BY_CLASSLOADER.set(newInstance);</span>
<span class="fc" id="L88">    }</span>

    // --------------------------------------------------------- Attributes

    /**
     * Logging for this instance
     */
<span class="fc" id="L95">    private final Log log = LogFactory.getLog(BeanUtilsBean.class);</span>

    /** Used to perform conversions between object types when setting properties */
    private final ConvertUtilsBean convertUtilsBean;

    /** Used to access properties*/
    private final PropertyUtilsBean propertyUtilsBean;

    /** A reference to Throwable's initCause method, or null if it's not there in this JVM */
<span class="fc" id="L104">    private static final Method INIT_CAUSE_METHOD = getInitCauseMethod();</span>

    // --------------------------------------------------------- Constuctors

    /**
     * &lt;p&gt;Constructs an instance using new property
     * and conversion instances.&lt;/p&gt;
     */
    public BeanUtilsBean() {
<span class="fc" id="L113">        this(new ConvertUtilsBean(), new PropertyUtilsBean());</span>
<span class="fc" id="L114">    }</span>

    /**
     * &lt;p&gt;Constructs an instance using given conversion instances
     * and new {@link PropertyUtilsBean} instance.&lt;/p&gt;
     *
     * @param convertUtilsBean use this &lt;code&gt;ConvertUtilsBean&lt;/code&gt;
     * to perform conversions from one object to another
     *
     * @since 1.8.0
     */
    public BeanUtilsBean(final ConvertUtilsBean convertUtilsBean) {
<span class="fc" id="L126">        this(convertUtilsBean, new PropertyUtilsBean());</span>
<span class="fc" id="L127">    }</span>

    /**
     * &lt;p&gt;Constructs an instance using given property and conversion instances.&lt;/p&gt;
     *
     * @param convertUtilsBean use this &lt;code&gt;ConvertUtilsBean&lt;/code&gt;
     * to perform conversions from one object to another
     * @param propertyUtilsBean use this &lt;code&gt;PropertyUtilsBean&lt;/code&gt;
     * to access properties
     */
    public BeanUtilsBean(
                            final ConvertUtilsBean convertUtilsBean,
<span class="fc" id="L139">                            final PropertyUtilsBean propertyUtilsBean) {</span>

<span class="fc" id="L141">        this.convertUtilsBean = convertUtilsBean;</span>
<span class="fc" id="L142">        this.propertyUtilsBean = propertyUtilsBean;</span>
<span class="fc" id="L143">    }</span>

    // --------------------------------------------------------- Public Methods

    /**
     * &lt;p&gt;Clone a bean based on the available property getters and setters,
     * even if the bean class itself does not implement Cloneable.&lt;/p&gt;
     *
     * &lt;p&gt;
     * &lt;strong&gt;Note:&lt;/strong&gt; this method creates a &lt;strong&gt;shallow&lt;/strong&gt; clone.
     * In other words, any objects referred to by the bean are shared with the clone
     * rather than being cloned in turn.
     * &lt;/p&gt;
     *
     * @param bean Bean to be cloned
     * @return the cloned bean
     *
     * @throws IllegalAccessException if the caller does not have
     *  access to the property accessor method
     * @throws InstantiationException if a new instance of the bean's
     *  class cannot be instantiated
     * @throws InvocationTargetException if the property accessor method
     *  throws an exception
     * @throws NoSuchMethodException if an accessor method for this
     *  property cannot be found
     */
    public Object cloneBean(final Object bean)
            throws IllegalAccessException, InstantiationException,
            InvocationTargetException, NoSuchMethodException {

<span class="pc bpc" id="L173" title="1 of 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L174">            log.debug(&quot;Cloning bean: &quot; + bean.getClass().getName());</span>
        }
<span class="fc" id="L176">        Object newBean = null;</span>
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">        if (bean instanceof DynaBean) {</span>
<span class="fc" id="L178">            newBean = ((DynaBean) bean).getDynaClass().newInstance();</span>
        } else {
<span class="nc" id="L180">            newBean = bean.getClass().newInstance();</span>
        }
<span class="fc" id="L182">        getPropertyUtils().copyProperties(newBean, bean);</span>
<span class="fc" id="L183">        return newBean;</span>

    }


    /**
     * &lt;p&gt;Copy property values from the origin bean to the destination bean
     * for all cases where the property names are the same.  For each
     * property, a conversion is attempted as necessary.  All combinations of
     * standard JavaBeans and DynaBeans as origin and destination are
     * supported.  Properties that exist in the origin bean, but do not exist
     * in the destination bean (or are read-only in the destination bean) are
     * silently ignored.&lt;/p&gt;
     *
     * &lt;p&gt;If the origin &quot;bean&quot; is actually a &lt;code&gt;Map&lt;/code&gt;, it is assumed
     * to contain String-valued &lt;strong&gt;simple&lt;/strong&gt; property names as the keys, pointing at
     * the corresponding property values that will be converted (if necessary)
     * and set in the destination bean. &lt;strong&gt;Note&lt;/strong&gt; that this method
     * is intended to perform a &quot;shallow copy&quot; of the properties and so complex
     * properties (for example, nested ones) will not be copied.&lt;/p&gt;
     *
     * &lt;p&gt;This method differs from &lt;code&gt;populate()&lt;/code&gt;, which
     * was primarily designed for populating JavaBeans from the map of request
     * parameters retrieved on an HTTP request, is that no scalar-&amp;gt;indexed
     * or indexed-&amp;gt;scalar manipulations are performed.  If the origin property
     * is indexed, the destination property must be also.&lt;/p&gt;
     *
     * &lt;p&gt;If you know that no type conversions are required, the
     * &lt;code&gt;copyProperties()&lt;/code&gt; method in {@link PropertyUtils} will
     * execute faster than this method.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;strong&gt;FIXME&lt;/strong&gt; - Indexed and mapped properties that do not
     * have getter and setter methods for the underlying array or Map are not
     * copied by this method.&lt;/p&gt;
     *
     * @param dest Destination bean whose properties are modified
     * @param orig Origin bean whose properties are retrieved
     *
     * @throws IllegalAccessException if the caller does not have
     *  access to the property accessor method
     * @throws IllegalArgumentException if the &lt;code&gt;dest&lt;/code&gt; or
     *  &lt;code&gt;orig&lt;/code&gt; argument is null or if the &lt;code&gt;dest&lt;/code&gt;
     *  property type is different from the source type and the relevant
     *  converter has not been registered.
     * @throws InvocationTargetException if the property accessor method
     *  throws an exception
     */
    public void copyProperties(final Object dest, final Object orig)
        throws IllegalAccessException, InvocationTargetException {

        // Validate existence of the specified beans
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">        if (dest == null) {</span>
<span class="nc" id="L235">            throw new IllegalArgumentException</span>
                    (&quot;No destination bean specified&quot;);
        }
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">        if (orig == null) {</span>
<span class="nc" id="L239">            throw new IllegalArgumentException(&quot;No origin bean specified&quot;);</span>
        }
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L242">            log.debug(&quot;BeanUtils.copyProperties(&quot; + dest + &quot;, &quot; +</span>
                      orig + &quot;)&quot;);
        }

        // Copy the properties, converting as necessary
<span class="fc bfc" id="L247" title="All 2 branches covered.">        if (orig instanceof DynaBean) {</span>
<span class="fc" id="L248">            final DynaProperty[] origDescriptors =</span>
<span class="fc" id="L249">                ((DynaBean) orig).getDynaClass().getDynaProperties();</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">            for (final DynaProperty origDescriptor : origDescriptors) {</span>
<span class="fc" id="L251">                final String name = origDescriptor.getName();</span>
                // Need to check isReadable() for WrapDynaBean
                // (see Jira issue# BEANUTILS-61)
<span class="fc bfc" id="L254" title="All 2 branches covered.">                if (getPropertyUtils().isReadable(orig, name) &amp;&amp;</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">                    getPropertyUtils().isWriteable(dest, name)) {</span>
<span class="fc" id="L256">                    final Object value = ((DynaBean) orig).get(name);</span>
<span class="fc" id="L257">                    copyProperty(dest, name, value);</span>
                }
            }
<span class="fc bfc" id="L260" title="All 2 branches covered.">        } else if (orig instanceof Map) {</span>
            @SuppressWarnings(&quot;unchecked&quot;)
            final
            // Map properties are always of type &lt;String, Object&gt;
<span class="fc" id="L264">            Map&lt;String, Object&gt; propMap = (Map&lt;String, Object&gt;) orig;</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">            for (final Map.Entry&lt;String, Object&gt; entry : propMap.entrySet()) {</span>
<span class="fc" id="L266">                final String name = entry.getKey();</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">                if (getPropertyUtils().isWriteable(dest, name)) {</span>
<span class="fc" id="L268">                    copyProperty(dest, name, entry.getValue());</span>
                }
<span class="fc" id="L270">            }</span>
<span class="fc" id="L271">        } else /* if (orig is a standard JavaBean) */ {</span>
<span class="fc" id="L272">            final PropertyDescriptor[] origDescriptors =</span>
<span class="fc" id="L273">                getPropertyUtils().getPropertyDescriptors(orig);</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">            for (final PropertyDescriptor origDescriptor : origDescriptors) {</span>
<span class="fc" id="L275">                final String name = origDescriptor.getName();</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">                if (&quot;class&quot;.equals(name)) {</span>
<span class="fc" id="L277">                    continue; // No point in trying to set an object's class</span>
                }
<span class="fc bfc" id="L279" title="All 2 branches covered.">                if (getPropertyUtils().isReadable(orig, name) &amp;&amp;</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">                    getPropertyUtils().isWriteable(dest, name)) {</span>
                    try {
<span class="fc" id="L282">                        final Object value =</span>
<span class="fc" id="L283">                            getPropertyUtils().getSimpleProperty(orig, name);</span>
<span class="fc" id="L284">                        copyProperty(dest, name, value);</span>
<span class="fc" id="L285">                    } catch (final NoSuchMethodException e) {</span>
                        // Should not happen
<span class="fc" id="L287">                    }</span>
                }
            }
        }

<span class="fc" id="L292">    }</span>


    /**
     * &lt;p&gt;Copy the specified property value to the specified destination bean,
     * performing any type conversion that is required.  If the specified
     * bean does not have a property of the specified name, or the property
     * is read only on the destination bean, return without
     * doing anything.  If you have custom destination property types, register
     * {@link Converter}s for them by calling the &lt;code&gt;register()&lt;/code&gt;
     * method of {@link ConvertUtils}.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;strong&gt;IMPLEMENTATION RESTRICTIONS&lt;/strong&gt;:&lt;/p&gt;
     * &lt;ul&gt;
     * &lt;li&gt;Does not support destination properties that are indexed,
     *     but only an indexed setter (as opposed to an array setter)
     *     is available.&lt;/li&gt;
     * &lt;li&gt;Does not support destination properties that are mapped,
     *     but only a keyed setter (as opposed to a Map setter)
     *     is available.&lt;/li&gt;
     * &lt;li&gt;The desired property type of a mapped setter cannot be
     *     determined (since Maps support any data type), so no conversion
     *     will be performed.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param bean Bean on which setting is to be performed
     * @param name Property name (can be nested/indexed/mapped/combo)
     * @param value Value to be set
     *
     * @throws IllegalAccessException if the caller does not have
     *  access to the property accessor method
     * @throws InvocationTargetException if the property accessor method
     *  throws an exception
     */
    public void copyProperty(final Object bean, String name, Object value)
        throws IllegalAccessException, InvocationTargetException {

        // Trace logging (if enabled)
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L331">            final StringBuilder sb = new StringBuilder(&quot;  copyProperty(&quot;);</span>
<span class="nc" id="L332">            sb.append(bean);</span>
<span class="nc" id="L333">            sb.append(&quot;, &quot;);</span>
<span class="nc" id="L334">            sb.append(name);</span>
<span class="nc" id="L335">            sb.append(&quot;, &quot;);</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">            if (value == null) {</span>
<span class="nc" id="L337">                sb.append(&quot;&lt;NULL&gt;&quot;);</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">            } else if (value instanceof String) {</span>
<span class="nc" id="L339">                sb.append((String) value);</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">            } else if (value instanceof String[]) {</span>
<span class="nc" id="L341">                final String[] values = (String[]) value;</span>
<span class="nc" id="L342">                sb.append('[');</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">                for (int i = 0; i &lt; values.length; i++) {</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">                    if (i &gt; 0) {</span>
<span class="nc" id="L345">                        sb.append(',');</span>
                    }
<span class="nc" id="L347">                    sb.append(values[i]);</span>
                }
<span class="nc" id="L349">                sb.append(']');</span>
<span class="nc" id="L350">            } else {</span>
<span class="nc" id="L351">                sb.append(value.toString());</span>
            }
<span class="nc" id="L353">            sb.append(')');</span>
<span class="nc" id="L354">            log.trace(sb.toString());</span>
        }

        // Resolve any nested expression to get the actual target bean
<span class="fc" id="L358">        Object target = bean;</span>
<span class="fc" id="L359">        final Resolver resolver = getPropertyUtils().getResolver();</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">        while (resolver.hasNested(name)) {</span>
            try {
<span class="fc" id="L362">                target = getPropertyUtils().getProperty(target, resolver.next(name));</span>
<span class="fc" id="L363">                name = resolver.remove(name);</span>
<span class="nc" id="L364">            } catch (final NoSuchMethodException e) {</span>
<span class="nc" id="L365">                return; // Skip this property setter</span>
<span class="fc" id="L366">            }</span>
        }
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L369">            log.trace(&quot;    Target bean = &quot; + target);</span>
<span class="nc" id="L370">            log.trace(&quot;    Target name = &quot; + name);</span>
        }

        // Declare local variables we will require
<span class="fc" id="L374">        final String propName = resolver.getProperty(name); // Simple name of target property</span>
<span class="fc" id="L375">        Class&lt;?&gt; type = null;                         // Java type of target property</span>
<span class="fc" id="L376">        final int index  = resolver.getIndex(name);         // Indexed subscript value (if any)</span>
<span class="fc" id="L377">        final String key = resolver.getKey(name);           // Mapped key value (if any)</span>

        // Calculate the target property type
<span class="fc bfc" id="L380" title="All 2 branches covered.">        if (target instanceof DynaBean) {</span>
<span class="fc" id="L381">            final DynaClass dynaClass = ((DynaBean) target).getDynaClass();</span>
<span class="fc" id="L382">            final DynaProperty dynaProperty = dynaClass.getDynaProperty(propName);</span>
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">            if (dynaProperty == null) {</span>
<span class="nc" id="L384">                return; // Skip this property setter</span>
            }
<span class="fc" id="L386">            type = dynaPropertyType(dynaProperty, value);</span>
<span class="fc" id="L387">        } else {</span>
<span class="fc" id="L388">            PropertyDescriptor descriptor = null;</span>
            try {
<span class="fc" id="L390">                descriptor =</span>
<span class="fc" id="L391">                    getPropertyUtils().getPropertyDescriptor(target, name);</span>
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">                if (descriptor == null) {</span>
<span class="nc" id="L393">                    return; // Skip this property setter</span>
                }
<span class="nc" id="L395">            } catch (final NoSuchMethodException e) {</span>
<span class="nc" id="L396">                return; // Skip this property setter</span>
<span class="fc" id="L397">            }</span>
<span class="fc" id="L398">            type = descriptor.getPropertyType();</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">            if (type == null) {</span>
                // Most likely an indexed setter on a POJB only
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">                if (log.isTraceEnabled()) {</span>
<span class="nc" id="L402">                    log.trace(&quot;    target type for property '&quot; +</span>
                              propName + &quot;' is null, so skipping ths setter&quot;);
                }
<span class="fc" id="L405">                return;</span>
            }
        }
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L409">            log.trace(&quot;    target propName=&quot; + propName + &quot;, type=&quot; +</span>
                      type + &quot;, index=&quot; + index + &quot;, key=&quot; + key);
        }

        // Convert the specified value to the required type and store it
<span class="fc bfc" id="L414" title="All 2 branches covered.">        if (index &gt;= 0) {                    // Destination must be indexed</span>
<span class="fc" id="L415">            value = convertForCopy(value, type.getComponentType());</span>
            try {
<span class="fc" id="L417">                getPropertyUtils().setIndexedProperty(target, propName,</span>
                                                 index, value);
<span class="nc" id="L419">            } catch (final NoSuchMethodException e) {</span>
<span class="nc" id="L420">                throw new InvocationTargetException</span>
                    (e, &quot;Cannot set &quot; + propName);
<span class="fc" id="L422">            }</span>
<span class="fc bfc" id="L423" title="All 2 branches covered.">        } else if (key != null) {            // Destination must be mapped</span>
            // Maps do not know what the preferred data type is,
            // so perform no conversions at all
            // FIXME - should we create or support a TypedMap?
            try {
<span class="fc" id="L428">                getPropertyUtils().setMappedProperty(target, propName,</span>
                                                key, value);
<span class="nc" id="L430">            } catch (final NoSuchMethodException e) {</span>
<span class="nc" id="L431">                throw new InvocationTargetException</span>
                    (e, &quot;Cannot set &quot; + propName);
<span class="fc" id="L433">            }</span>
        } else {                             // Destination must be simple
<span class="fc" id="L435">            value = convertForCopy(value, type);</span>
            try {
<span class="fc" id="L437">                getPropertyUtils().setSimpleProperty(target, propName, value);</span>
<span class="nc" id="L438">            } catch (final NoSuchMethodException e) {</span>
<span class="nc" id="L439">                throw new InvocationTargetException</span>
                    (e, &quot;Cannot set &quot; + propName);
<span class="fc" id="L441">            }</span>
        }

<span class="fc" id="L444">    }</span>


    /**
     * &lt;p&gt;Return the entire set of properties for which the specified bean
     * provides a read method. This map contains the to &lt;code&gt;String&lt;/code&gt;
     * converted property values for all properties for which a read method
     * is provided (i.e. where the getReadMethod() returns non-null).&lt;/p&gt;
     *
     * &lt;p&gt;This map can be fed back to a call to
     * &lt;code&gt;BeanUtils.populate()&lt;/code&gt; to reconsitute the same set of
     * properties, modulo differences for read-only and write-only
     * properties, but only if there are no indexed properties.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; if any of the bean property implementations
     * contain (directly or indirectly) a call to this method then
     * a stack overflow may result. For example:&lt;/p&gt;
     * &lt;pre&gt;&lt;code&gt;
     * class MyBean
     * {
     *    public Map getParameterMap()
     *    {
     *         BeanUtils.describe(this);
     *    }
     * }
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;p&gt;
     * will result in an infinite regression when &lt;code&gt;getParametersMap&lt;/code&gt;
     * is called. It is recommended that such methods are given alternative
     * names (for example, &lt;code&gt;parametersMap&lt;/code&gt;).
     * &lt;/p&gt;
     * @param bean Bean whose properties are to be extracted
     * @return Map of property descriptors
     *
     * @throws IllegalAccessException if the caller does not have
     *  access to the property accessor method
     * @throws InvocationTargetException if the property accessor method
     *  throws an exception
     * @throws NoSuchMethodException if an accessor method for this
     *  property cannot be found
     */
    public Map&lt;String, String&gt; describe(final Object bean)
            throws IllegalAccessException, InvocationTargetException,
            NoSuchMethodException {

<span class="pc bpc" id="L489" title="1 of 2 branches missed.">        if (bean == null) {</span>
        //            return (Collections.EMPTY_MAP);
<span class="nc" id="L491">            return new java.util.HashMap&lt;&gt;();</span>
        }

<span class="pc bpc" id="L494" title="1 of 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L495">            log.debug(&quot;Describing bean: &quot; + bean.getClass().getName());</span>
        }

<span class="fc" id="L498">        final Map&lt;String, String&gt; description = new HashMap&lt;&gt;();</span>
<span class="pc bpc" id="L499" title="1 of 2 branches missed.">        if (bean instanceof DynaBean) {</span>
<span class="nc" id="L500">            final DynaProperty[] descriptors =</span>
<span class="nc" id="L501">                ((DynaBean) bean).getDynaClass().getDynaProperties();</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">            for (final DynaProperty descriptor : descriptors) {</span>
<span class="nc" id="L503">                final String name = descriptor.getName();</span>
<span class="nc" id="L504">                description.put(name, getProperty(bean, name));</span>
            }
<span class="nc" id="L506">        } else {</span>
<span class="fc" id="L507">            final PropertyDescriptor[] descriptors =</span>
<span class="fc" id="L508">                getPropertyUtils().getPropertyDescriptors(bean);</span>
<span class="fc" id="L509">            final Class&lt;?&gt; clazz = bean.getClass();</span>
<span class="fc bfc" id="L510" title="All 2 branches covered.">            for (final PropertyDescriptor descriptor : descriptors) {</span>
<span class="fc" id="L511">                final String name = descriptor.getName();</span>
<span class="fc bfc" id="L512" title="All 2 branches covered.">                if (getPropertyUtils().getReadMethod(clazz, descriptor) != null) {</span>
<span class="fc" id="L513">                    description.put(name, getProperty(bean, name));</span>
                }
            }
        }
<span class="fc" id="L517">        return description;</span>

    }


    /**
     * Return the value of the specified array property of the specified
     * bean, as a String array.
     *
     * @param bean Bean whose property is to be extracted
     * @param name Name of the property to be extracted
     * @return The array property value
     *
     * @throws IllegalAccessException if the caller does not have
     *  access to the property accessor method
     * @throws InvocationTargetException if the property accessor method
     *  throws an exception
     * @throws NoSuchMethodException if an accessor method for this
     *  property cannot be found
     */
    public String[] getArrayProperty(final Object bean, final String name)
            throws IllegalAccessException, InvocationTargetException,
            NoSuchMethodException {

<span class="fc" id="L541">        final Object value = getPropertyUtils().getProperty(bean, name);</span>
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L543">            return null;</span>
<span class="pc bpc" id="L544" title="1 of 2 branches missed.">        } else if (value instanceof Collection) {</span>
<span class="nc" id="L545">            final ArrayList&lt;String&gt; values = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">            for (final Object item : (Collection&lt;?&gt;) value) {</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">                if (item == null) {</span>
<span class="nc" id="L548">                    values.add(null);</span>
                } else {
                    // convert to string using convert utils
<span class="nc" id="L551">                    values.add(getConvertUtils().convert(item));</span>
                }
<span class="nc" id="L553">            }</span>
<span class="nc" id="L554">            return values.toArray(new String[values.size()]);</span>
<span class="fc bfc" id="L555" title="All 2 branches covered.">        } else if (value.getClass().isArray()) {</span>
<span class="fc" id="L556">            final int n = Array.getLength(value);</span>
<span class="fc" id="L557">            final String[] results = new String[n];</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L559">                final Object item = Array.get(value, i);</span>
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">                if (item == null) {</span>
<span class="nc" id="L561">                    results[i] = null;</span>
                } else {
                    // convert to string using convert utils
<span class="fc" id="L564">                    results[i] = getConvertUtils().convert(item);</span>
                }
            }
<span class="fc" id="L567">            return results;</span>
        } else {
<span class="fc" id="L569">            final String[] results = new String[1];</span>
<span class="fc" id="L570">            results[0] = getConvertUtils().convert(value);</span>
<span class="fc" id="L571">            return results;</span>
        }

    }


    /**
     * Return the value of the specified indexed property of the specified
     * bean, as a String.  The zero-relative index of the
     * required value must be included (in square brackets) as a suffix to
     * the property name, or &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be
     * thrown.
     *
     * @param bean Bean whose property is to be extracted
     * @param name &lt;code&gt;propertyname[index]&lt;/code&gt; of the property value
     *  to be extracted
     * @return The indexed property's value, converted to a String
     *
     * @throws IllegalAccessException if the caller does not have
     *  access to the property accessor method
     * @throws InvocationTargetException if the property accessor method
     *  throws an exception
     * @throws NoSuchMethodException if an accessor method for this
     *  property cannot be found
     */
    public String getIndexedProperty(final Object bean, final String name)
            throws IllegalAccessException, InvocationTargetException,
            NoSuchMethodException {

<span class="fc" id="L600">        final Object value = getPropertyUtils().getIndexedProperty(bean, name);</span>
<span class="fc" id="L601">        return getConvertUtils().convert(value);</span>

    }


    /**
     * Return the value of the specified indexed property of the specified
     * bean, as a String.  The index is specified as a method parameter and
     * must *not* be included in the property name expression
     *
     * @param bean Bean whose property is to be extracted
     * @param name Simple property name of the property value to be extracted
     * @param index Index of the property value to be extracted
     * @return The indexed property's value, converted to a String
     *
     * @throws IllegalAccessException if the caller does not have
     *  access to the property accessor method
     * @throws InvocationTargetException if the property accessor method
     *  throws an exception
     * @throws NoSuchMethodException if an accessor method for this
     *  property cannot be found
     */
    public String getIndexedProperty(final Object bean,
                                            final String name, final int index)
            throws IllegalAccessException, InvocationTargetException,
            NoSuchMethodException {

<span class="fc" id="L628">        final Object value = getPropertyUtils().getIndexedProperty(bean, name, index);</span>
<span class="fc" id="L629">        return getConvertUtils().convert(value);</span>

    }


    /**
     * Return the value of the specified indexed property of the specified
     * bean, as a String.  The String-valued key of the required value
     * must be included (in parentheses) as a suffix to
     * the property name, or &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be
     * thrown.
     *
     * @param bean Bean whose property is to be extracted
     * @param name &lt;code&gt;propertyname(index)&lt;/code&gt; of the property value
     *  to be extracted
     * @return The mapped property's value, converted to a String
     *
     * @throws IllegalAccessException if the caller does not have
     *  access to the property accessor method
     * @throws InvocationTargetException if the property accessor method
     *  throws an exception
     * @throws NoSuchMethodException if an accessor method for this
     *  property cannot be found
     */
    public String getMappedProperty(final Object bean, final String name)
            throws IllegalAccessException, InvocationTargetException,
            NoSuchMethodException {

<span class="nc" id="L657">        final Object value = getPropertyUtils().getMappedProperty(bean, name);</span>
<span class="nc" id="L658">        return getConvertUtils().convert(value);</span>

    }


    /**
     * Return the value of the specified mapped property of the specified
     * bean, as a String.  The key is specified as a method parameter and
     * must *not* be included in the property name expression
     *
     * @param bean Bean whose property is to be extracted
     * @param name Simple property name of the property value to be extracted
     * @param key Lookup key of the property value to be extracted
     * @return The mapped property's value, converted to a String
     *
     * @throws IllegalAccessException if the caller does not have
     *  access to the property accessor method
     * @throws InvocationTargetException if the property accessor method
     *  throws an exception
     * @throws NoSuchMethodException if an accessor method for this
     *  property cannot be found
     */
    public String getMappedProperty(final Object bean,
                                           final String name, final String key)
            throws IllegalAccessException, InvocationTargetException,
            NoSuchMethodException {

<span class="nc" id="L685">        final Object value = getPropertyUtils().getMappedProperty(bean, name, key);</span>
<span class="nc" id="L686">        return getConvertUtils().convert(value);</span>

    }


    /**
     * Return the value of the (possibly nested) property of the specified
     * name, for the specified bean, as a String.
     *
     * @param bean Bean whose property is to be extracted
     * @param name Possibly nested name of the property to be extracted
     * @return The nested property's value, converted to a String
     *
     * @throws IllegalAccessException if the caller does not have
     *  access to the property accessor method
     * @throws IllegalArgumentException if a nested reference to a
     *  property returns null
     * @throws InvocationTargetException if the property accessor method
     *  throws an exception
     * @throws NoSuchMethodException if an accessor method for this
     *  property cannot be found
     */
    public String getNestedProperty(final Object bean, final String name)
            throws IllegalAccessException, InvocationTargetException,
            NoSuchMethodException {

<span class="fc" id="L712">        final Object value = getPropertyUtils().getNestedProperty(bean, name);</span>
<span class="fc" id="L713">        return getConvertUtils().convert(value);</span>

    }


    /**
     * Return the value of the specified property of the specified bean,
     * no matter which property reference format is used, as a String.
     *
     * @param bean Bean whose property is to be extracted
     * @param name Possibly indexed and/or nested name of the property
     *  to be extracted
     * @return The property's value, converted to a String
     *
     * @throws IllegalAccessException if the caller does not have
     *  access to the property accessor method
     * @throws InvocationTargetException if the property accessor method
     *  throws an exception
     * @throws NoSuchMethodException if an accessor method for this
     *  property cannot be found
     */
    public String getProperty(final Object bean, final String name)
            throws IllegalAccessException, InvocationTargetException,
            NoSuchMethodException {

<span class="fc" id="L738">        return getNestedProperty(bean, name);</span>

    }


    /**
     * Return the value of the specified simple property of the specified
     * bean, converted to a String.
     *
     * @param bean Bean whose property is to be extracted
     * @param name Name of the property to be extracted
     * @return The property's value, converted to a String
     *
     * @throws IllegalAccessException if the caller does not have
     *  access to the property accessor method
     * @throws InvocationTargetException if the property accessor method
     *  throws an exception
     * @throws NoSuchMethodException if an accessor method for this
     *  property cannot be found
     */
    public String getSimpleProperty(final Object bean, final String name)
            throws IllegalAccessException, InvocationTargetException,
            NoSuchMethodException {

<span class="fc" id="L762">        final Object value = getPropertyUtils().getSimpleProperty(bean, name);</span>
<span class="fc" id="L763">        return getConvertUtils().convert(value);</span>

    }


    /**
     * &lt;p&gt;Populate the JavaBeans properties of the specified bean, based on
     * the specified name/value pairs.  This method uses Java reflection APIs
     * to identify corresponding &quot;property setter&quot; method names, and deals
     * with setter arguments of type &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;,
     * &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, and
     * &lt;code&gt;double&lt;/code&gt;.  In addition, array setters for these types (or the
     * corresponding primitive types) can also be identified.&lt;/p&gt;
     *
     * &lt;p&gt;The particular setter method to be called for each property is
     * determined using the usual JavaBeans introspection mechanisms.  Thus,
     * you may identify custom setter methods using a BeanInfo class that is
     * associated with the class of the bean itself.  If no such BeanInfo
     * class is available, the standard method name conversion (&quot;set&quot; plus
     * the capitalized name of the property in question) is used.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;:  It is contrary to the JavaBeans Specification
     * to have more than one setter method (with different argument
     * signatures) for the same property.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt; - The logic of this method is customized
     * for extracting String-based request parameters from an HTTP request.
     * It is probably not what you want for general property copying with
     * type conversion.  For that purpose, check out the
     * &lt;code&gt;copyProperties()&lt;/code&gt; method instead.&lt;/p&gt;
     *
     * @param bean JavaBean whose properties are being populated
     * @param properties Map keyed by property name, with the
     *  corresponding (String or String[]) value(s) to be set
     *
     * @throws IllegalAccessException if the caller does not have
     *  access to the property accessor method
     * @throws InvocationTargetException if the property accessor method
     *  throws an exception
     */
    public void populate(final Object bean, final Map&lt;String, ? extends Object&gt; properties)
        throws IllegalAccessException, InvocationTargetException {

        // Do nothing unless both arguments have been specified
<span class="pc bpc" id="L807" title="2 of 4 branches missed.">        if (bean == null || properties == null) {</span>
<span class="nc" id="L808">            return;</span>
        }
<span class="pc bpc" id="L810" title="1 of 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L811">            log.debug(&quot;BeanUtils.populate(&quot; + bean + &quot;, &quot; +</span>
                    properties + &quot;)&quot;);
        }

        // Loop through the property name/value pairs to be set
<span class="fc bfc" id="L816" title="All 2 branches covered.">        for(final Map.Entry&lt;String, ? extends Object&gt; entry : properties.entrySet()) {</span>
            // Identify the property name and value(s) to be assigned
<span class="fc" id="L818">            final String name = entry.getKey();</span>
<span class="pc bpc" id="L819" title="1 of 2 branches missed.">            if (name == null) {</span>
<span class="nc" id="L820">                continue;</span>
            }

            // Perform the assignment for this property
<span class="fc" id="L824">            setProperty(bean, name, entry.getValue());</span>

<span class="fc" id="L826">        }</span>

<span class="fc" id="L828">    }</span>


    /**
     * &lt;p&gt;Set the specified property value, performing type conversions as
     * required to conform to the type of the destination property.&lt;/p&gt;
     *
     * &lt;p&gt;If the property is read only then the method returns
     * without throwing an exception.&lt;/p&gt;
     *
     * &lt;p&gt;If &lt;code&gt;null&lt;/code&gt; is passed into a property expecting a primitive value,
     * then this will be converted as if it were a &lt;code&gt;null&lt;/code&gt; string.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt; - The logic of this method is customized
     * to meet the needs of &lt;code&gt;populate()&lt;/code&gt;, and is probably not what
     * you want for general property copying with type conversion.  For that
     * purpose, check out the &lt;code&gt;copyProperty()&lt;/code&gt; method instead.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt; - PLEASE do not modify the behavior of this
     * method without consulting with the Struts developer community.  There
     * are some subtleties to its functionality that are not documented in the
     * Javadoc description above, yet are vital to the way that Struts utilizes
     * this method.&lt;/p&gt;
     *
     * @param bean Bean on which setting is to be performed
     * @param name Property name (can be nested/indexed/mapped/combo)
     * @param value Value to be set
     *
     * @throws IllegalAccessException if the caller does not have
     *  access to the property accessor method
     * @throws InvocationTargetException if the property accessor method
     *  throws an exception
     */
    public void setProperty(final Object bean, String name, final Object value)
        throws IllegalAccessException, InvocationTargetException {

        // Trace logging (if enabled)
<span class="pc bpc" id="L865" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L866">            final StringBuilder sb = new StringBuilder(&quot;  setProperty(&quot;);</span>
<span class="nc" id="L867">            sb.append(bean);</span>
<span class="nc" id="L868">            sb.append(&quot;, &quot;);</span>
<span class="nc" id="L869">            sb.append(name);</span>
<span class="nc" id="L870">            sb.append(&quot;, &quot;);</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">            if (value == null) {</span>
<span class="nc" id="L872">                sb.append(&quot;&lt;NULL&gt;&quot;);</span>
<span class="nc bnc" id="L873" title="All 2 branches missed.">            } else if (value instanceof String) {</span>
<span class="nc" id="L874">                sb.append((String) value);</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">            } else if (value instanceof String[]) {</span>
<span class="nc" id="L876">                final String[] values = (String[]) value;</span>
<span class="nc" id="L877">                sb.append('[');</span>
<span class="nc bnc" id="L878" title="All 2 branches missed.">                for (int i = 0; i &lt; values.length; i++) {</span>
<span class="nc bnc" id="L879" title="All 2 branches missed.">                    if (i &gt; 0) {</span>
<span class="nc" id="L880">                        sb.append(',');</span>
                    }
<span class="nc" id="L882">                    sb.append(values[i]);</span>
                }
<span class="nc" id="L884">                sb.append(']');</span>
<span class="nc" id="L885">            } else {</span>
<span class="nc" id="L886">                sb.append(value.toString());</span>
            }
<span class="nc" id="L888">            sb.append(')');</span>
<span class="nc" id="L889">            log.trace(sb.toString());</span>
        }

        // Resolve any nested expression to get the actual target bean
<span class="fc" id="L893">        Object target = bean;</span>
<span class="fc" id="L894">        final Resolver resolver = getPropertyUtils().getResolver();</span>
<span class="fc bfc" id="L895" title="All 2 branches covered.">        while (resolver.hasNested(name)) {</span>
            try {
<span class="fc" id="L897">                target = getPropertyUtils().getProperty(target, resolver.next(name));</span>
<span class="fc bfc" id="L898" title="All 2 branches covered.">                if (target == null) { // the value of a nested property is null</span>
<span class="fc" id="L899">                    return;</span>
                }
<span class="fc" id="L901">                name = resolver.remove(name);</span>
<span class="nc" id="L902">            } catch (final NoSuchMethodException e) {</span>
<span class="nc" id="L903">                return; // Skip this property setter</span>
<span class="fc" id="L904">            }</span>
        }
<span class="pc bpc" id="L906" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L907">            log.trace(&quot;    Target bean = &quot; + target);</span>
<span class="nc" id="L908">            log.trace(&quot;    Target name = &quot; + name);</span>
        }

        // Declare local variables we will require
<span class="fc" id="L912">        final String propName = resolver.getProperty(name); // Simple name of target property</span>
<span class="fc" id="L913">        Class&lt;?&gt; type = null;                         // Java type of target property</span>
<span class="fc" id="L914">        final int index  = resolver.getIndex(name);         // Indexed subscript value (if any)</span>
<span class="fc" id="L915">        final String key = resolver.getKey(name);           // Mapped key value (if any)</span>

        // Calculate the property type
<span class="fc bfc" id="L918" title="All 2 branches covered.">        if (target instanceof DynaBean) {</span>
<span class="fc" id="L919">            final DynaClass dynaClass = ((DynaBean) target).getDynaClass();</span>
<span class="fc" id="L920">            final DynaProperty dynaProperty = dynaClass.getDynaProperty(propName);</span>
<span class="pc bpc" id="L921" title="1 of 2 branches missed.">            if (dynaProperty == null) {</span>
<span class="nc" id="L922">                return; // Skip this property setter</span>
            }
<span class="fc" id="L924">            type = dynaPropertyType(dynaProperty, value);</span>
<span class="fc bfc" id="L925" title="All 4 branches covered.">            if (index &gt;= 0 &amp;&amp; List.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L926">            	type = Object.class;</span>
            }
<span class="fc bfc" id="L928" title="All 2 branches covered.">        } else if (target instanceof Map) {</span>
<span class="fc" id="L929">            type = Object.class;</span>
<span class="pc bpc" id="L930" title="1 of 6 branches missed.">        } else if (target != null &amp;&amp; target.getClass().isArray() &amp;&amp; index &gt;= 0) {</span>
<span class="fc" id="L931">            type = Array.get(target, index).getClass();</span>
        } else {
<span class="fc" id="L933">            PropertyDescriptor descriptor = null;</span>
            try {
<span class="fc" id="L935">                descriptor =</span>
<span class="fc" id="L936">                    getPropertyUtils().getPropertyDescriptor(target, name);</span>
<span class="pc bpc" id="L937" title="1 of 2 branches missed.">                if (descriptor == null) {</span>
<span class="nc" id="L938">                    return; // Skip this property setter</span>
                }
<span class="nc" id="L940">            } catch (final NoSuchMethodException e) {</span>
<span class="nc" id="L941">                return; // Skip this property setter</span>
<span class="fc" id="L942">            }</span>
<span class="fc bfc" id="L943" title="All 2 branches covered.">            if (descriptor instanceof MappedPropertyDescriptor) {</span>
<span class="pc bpc" id="L944" title="1 of 2 branches missed.">                if (((MappedPropertyDescriptor) descriptor).getMappedWriteMethod() == null) {</span>
<span class="nc bnc" id="L945" title="All 2 branches missed.">                    if (log.isDebugEnabled()) {</span>
<span class="nc" id="L946">                        log.debug(&quot;Skipping read-only property&quot;);</span>
                    }
<span class="nc" id="L948">                    return; // Read-only, skip this property setter</span>
                }
<span class="fc" id="L950">                type = ((MappedPropertyDescriptor) descriptor).</span>
<span class="fc" id="L951">                    getMappedPropertyType();</span>
<span class="fc bfc" id="L952" title="All 4 branches covered.">            } else if (index &gt;= 0 &amp;&amp; descriptor instanceof IndexedPropertyDescriptor) {</span>
<span class="pc bpc" id="L953" title="1 of 2 branches missed.">                if (((IndexedPropertyDescriptor) descriptor).getIndexedWriteMethod() == null) {</span>
<span class="nc bnc" id="L954" title="All 2 branches missed.">                    if (log.isDebugEnabled()) {</span>
<span class="nc" id="L955">                        log.debug(&quot;Skipping read-only property&quot;);</span>
                    }
<span class="nc" id="L957">                    return; // Read-only, skip this property setter</span>
                }
<span class="fc" id="L959">                type = ((IndexedPropertyDescriptor) descriptor).</span>
<span class="fc" id="L960">                    getIndexedPropertyType();</span>
<span class="fc bfc" id="L961" title="All 4 branches covered.">            } else if (index &gt;= 0 &amp;&amp; List.class.isAssignableFrom(descriptor.getPropertyType())) {</span>
<span class="fc" id="L962">                type = Object.class;</span>
<span class="fc bfc" id="L963" title="All 2 branches covered.">            } else if (key != null) {</span>
<span class="pc bpc" id="L964" title="1 of 2 branches missed.">                if (descriptor.getReadMethod() == null) {</span>
<span class="nc bnc" id="L965" title="All 2 branches missed.">                    if (log.isDebugEnabled()) {</span>
<span class="nc" id="L966">                        log.debug(&quot;Skipping read-only property&quot;);</span>
                    }
<span class="nc" id="L968">                    return; // Read-only, skip this property setter</span>
                }
<span class="pc bpc" id="L970" title="1 of 2 branches missed.">                type = value == null ? Object.class : value.getClass();</span>
            } else {
<span class="fc bfc" id="L972" title="All 2 branches covered.">                if (descriptor.getWriteMethod() == null) {</span>
<span class="pc bpc" id="L973" title="1 of 2 branches missed.">                    if (log.isDebugEnabled()) {</span>
<span class="nc" id="L974">                        log.debug(&quot;Skipping read-only property&quot;);</span>
                    }
<span class="fc" id="L976">                    return; // Read-only, skip this property setter</span>
                }
<span class="fc" id="L978">                type = descriptor.getPropertyType();</span>
            }
        }

        // Convert the specified value to the required type
<span class="fc" id="L983">        Object newValue = null;</span>
<span class="fc bfc" id="L984" title="All 4 branches covered.">        if (type.isArray() &amp;&amp; index &lt; 0) { // Scalar value into array</span>
<span class="fc bfc" id="L985" title="All 2 branches covered.">            if (value == null) {</span>
<span class="fc" id="L986">                final String[] values = new String[1];</span>
<span class="fc" id="L987">                values[0] = null;</span>
<span class="fc" id="L988">                newValue = getConvertUtils().convert(values, type);</span>
<span class="fc bfc" id="L989" title="All 2 branches covered.">            } else if (value instanceof String) {</span>
<span class="fc" id="L990">                newValue = getConvertUtils().convert(value, type);</span>
<span class="fc bfc" id="L991" title="All 2 branches covered.">            } else if (value instanceof String[]) {</span>
<span class="fc" id="L992">                newValue = getConvertUtils().convert((String[]) value, type);</span>
            } else {
<span class="fc" id="L994">                newValue = convert(value, type);</span>
            }
<span class="fc bfc" id="L996" title="All 2 branches covered.">        } else if (type.isArray()) {         // Indexed value into array</span>
<span class="fc bfc" id="L997" title="All 4 branches covered.">            if (value instanceof String || value == null) {</span>
<span class="fc" id="L998">                newValue = getConvertUtils().convert((String) value,</span>
<span class="fc" id="L999">                                                type.getComponentType());</span>
<span class="pc bpc" id="L1000" title="1 of 2 branches missed.">            } else if (value instanceof String[]) {</span>
<span class="nc" id="L1001">                newValue = getConvertUtils().convert(((String[]) value)[0],</span>
<span class="nc" id="L1002">                                                type.getComponentType());</span>
            } else {
<span class="fc" id="L1004">                newValue = convert(value, type.getComponentType());</span>
            }
        } else {                             // Value into scalar
<span class="fc bfc" id="L1007" title="All 2 branches covered.">            if (value instanceof String) {</span>
<span class="fc" id="L1008">                newValue = getConvertUtils().convert((String) value, type);</span>
<span class="pc bpc" id="L1009" title="1 of 2 branches missed.">            } else if (value instanceof String[]) {</span>
<span class="nc" id="L1010">                newValue = getConvertUtils().convert(((String[]) value)[0],</span>
                                                type);
            } else {
<span class="fc" id="L1013">                newValue = convert(value, type);</span>
            }
        }

        // Invoke the setter method
        try {
<span class="fc" id="L1019">          getPropertyUtils().setProperty(target, name, newValue);</span>
<span class="nc" id="L1020">        } catch (final NoSuchMethodException e) {</span>
<span class="nc" id="L1021">            throw new InvocationTargetException</span>
                (e, &quot;Cannot set &quot; + propName);
<span class="fc" id="L1023">        }</span>

<span class="fc" id="L1025">    }</span>

    /**
     * Gets the &lt;code&gt;ConvertUtilsBean&lt;/code&gt; instance used to perform the conversions.
     *
     * @return The ConvertUtils bean instance
     */
    public ConvertUtilsBean getConvertUtils() {
<span class="fc" id="L1033">        return convertUtilsBean;</span>
    }

    /**
     * Gets the &lt;code&gt;PropertyUtilsBean&lt;/code&gt; instance used to access properties.
     *
     * @return The ConvertUtils bean instance
     */
    public PropertyUtilsBean getPropertyUtils() {
<span class="fc" id="L1042">        return propertyUtilsBean;</span>
    }

    /**
     * If we're running on JDK 1.4 or later, initialize the cause for the given throwable.
     *
     * @param  throwable The throwable.
     * @param  cause     The cause of the throwable.
     * @return  true if the cause was initialized, otherwise false.
     * @since 1.8.0
     */
    public boolean initCause(final Throwable throwable, final Throwable cause) {
<span class="pc bpc" id="L1054" title="2 of 4 branches missed.">        if (INIT_CAUSE_METHOD != null &amp;&amp; cause != null) {</span>
            try {
<span class="fc" id="L1056">                INIT_CAUSE_METHOD.invoke(throwable, new Object[] { cause });</span>
<span class="fc" id="L1057">                return true;</span>
<span class="nc" id="L1058">            } catch (final Throwable e) {</span>
<span class="nc" id="L1059">                return false; // can't initialize cause</span>
            }
        }
<span class="nc" id="L1062">        return false;</span>
    }

    /**
     * &lt;p&gt;Convert the value to an object of the specified class (if
     * possible).&lt;/p&gt;
     *
     * @param value Value to be converted (may be null)
     * @param type Class of the value to be converted to
     * @return The converted value
     *
     * @throws ConversionException if thrown by an underlying Converter
     * @since 1.8.0
     */
    protected Object convert(final Object value, final Class&lt;?&gt; type) {
<span class="fc" id="L1077">        final Converter converter = getConvertUtils().lookup(type);</span>
<span class="fc bfc" id="L1078" title="All 2 branches covered.">        if (converter != null) {</span>
<span class="fc" id="L1079">            log.trace(&quot;        USING CONVERTER &quot; + converter);</span>
<span class="fc" id="L1080">            return converter.convert(type, value);</span>
        }
<span class="fc" id="L1082">        return value;</span>
    }

    /**
     * Performs a type conversion of a property value before it is copied to a target
     * bean. This method delegates to {@link #convert(Object, Class)}, but &lt;b&gt;null&lt;/b&gt;
     * values are not converted. This causes &lt;b&gt;null&lt;/b&gt; values to be copied verbatim.
     *
     * @param value the value to be converted and copied
     * @param type the target type of the conversion
     * @return the converted value
     */
    private Object convertForCopy(final Object value, final Class&lt;?&gt; type) {
<span class="fc bfc" id="L1095" title="All 2 branches covered.">        return value != null ? convert(value, type) : value;</span>
    }

    /**
     * Returns a &lt;code&gt;Method&lt;code&gt; allowing access to
     * {@link Throwable#initCause(Throwable)} method of {@link Throwable},
     * or &lt;code&gt;null&lt;/code&gt; if the method
     * does not exist.
     *
     * @return A &lt;code&gt;Method&lt;code&gt; for &lt;code&gt;Throwable.initCause&lt;/code&gt;, or
     * &lt;code&gt;null&lt;/code&gt; if unavailable.
     */
    private static Method getInitCauseMethod() {
        try {
<span class="fc" id="L1109">            final Class&lt;?&gt;[] paramsClasses = new Class&lt;?&gt;[] { Throwable.class };</span>
<span class="fc" id="L1110">            return Throwable.class.getMethod(&quot;initCause&quot;, paramsClasses);</span>
<span class="nc" id="L1111">        } catch (final NoSuchMethodException e) {</span>
<span class="nc" id="L1112">            final Log log = LogFactory.getLog(BeanUtils.class);</span>
<span class="nc bnc" id="L1113" title="All 2 branches missed.">            if (log.isWarnEnabled()) {</span>
<span class="nc" id="L1114">                log.warn(&quot;Throwable does not have initCause() method in JDK 1.3&quot;);</span>
            }
<span class="nc" id="L1116">            return null;</span>
<span class="nc" id="L1117">        } catch (final Throwable e) {</span>
<span class="nc" id="L1118">            final Log log = LogFactory.getLog(BeanUtils.class);</span>
<span class="nc bnc" id="L1119" title="All 2 branches missed.">            if (log.isWarnEnabled()) {</span>
<span class="nc" id="L1120">                log.warn(&quot;Error getting the Throwable initCause() method&quot;, e);</span>
            }
<span class="nc" id="L1122">            return null;</span>
        }
    }

    /**
     * Determines the type of a {@code DynaProperty}. Here a special treatment
     * is needed for mapped properties.
     *
     * @param dynaProperty the property descriptor
     * @param value the value object to be set for this property
     * @return the type of this property
     */
    private static Class&lt;?&gt; dynaPropertyType(final DynaProperty dynaProperty,
            final Object value) {
<span class="fc bfc" id="L1136" title="All 2 branches covered.">        if (!dynaProperty.isMapped()) {</span>
<span class="fc" id="L1137">            return dynaProperty.getType();</span>
        }
<span class="fc bfc" id="L1139" title="All 2 branches covered.">        return value == null ? String.class : value.getClass();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>