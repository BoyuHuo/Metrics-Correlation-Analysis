<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LazyDynaBean.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons BeanUtils</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.beanutils2</a> &gt; <span class="el_source">LazyDynaBean.java</span></div><h1>LazyDynaBean.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.beanutils2;

import java.io.Serializable;
import java.lang.reflect.Array;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * &lt;p&gt;DynaBean which automatically adds properties to the &lt;code&gt;DynaClass&lt;/code&gt;
 *   and provides &lt;i&gt;Lazy List&lt;/i&gt; and &lt;i&gt;Lazy Map&lt;/i&gt; features.&lt;/p&gt;
 *
 * &lt;p&gt;DynaBeans deal with three types of properties - &lt;i&gt;simple&lt;/i&gt;, &lt;i&gt;indexed&lt;/i&gt; and &lt;i&gt;mapped&lt;/i&gt; and
 *    have the following &lt;code&gt;get()&lt;/code&gt; and &lt;code&gt;set()&lt;/code&gt; methods for
 *    each of these types:&lt;/p&gt;
 *    &lt;ul&gt;
 *        &lt;li&gt;&lt;i&gt;Simple&lt;/i&gt; property methods - &lt;code&gt;get(name)&lt;/code&gt; and
 *                          &lt;code&gt;set(name, value)&lt;/code&gt;&lt;/li&gt;
 *        &lt;li&gt;&lt;i&gt;Indexed&lt;/i&gt; property methods - &lt;code&gt;get(name, index)&lt;/code&gt; and
 *                          &lt;code&gt;set(name, index, value)&lt;/code&gt;&lt;/li&gt;
 *        &lt;li&gt;&lt;i&gt;Mapped&lt;/i&gt; property methods - &lt;code&gt;get(name, key)&lt;/code&gt; and
 *                          &lt;code&gt;set(name, key, value)&lt;/code&gt;&lt;/li&gt;
 *    &lt;/ul&gt;
 *
 * &lt;p&gt;&lt;b&gt;&lt;u&gt;Getting Property Values&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;Calling any of the &lt;code&gt;get()&lt;/code&gt; methods, for a property which
 *    doesn't exist, returns &lt;code&gt;null&lt;/code&gt; in this implementation.&lt;/p&gt;
 *
 * &lt;p&gt;&lt;b&gt;&lt;u&gt;Setting Simple Properties&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;
 *    &lt;p&gt;The &lt;code&gt;LazyDynaBean&lt;/code&gt; will automatically add a property to the &lt;code&gt;DynaClass&lt;/code&gt;
 *       if it doesn't exist when the &lt;code&gt;set(name, value)&lt;/code&gt; method is called.&lt;/p&gt;
 *
 *     &lt;pre&gt;&lt;code&gt;
 *         DynaBean myBean = new LazyDynaBean();
 *         myBean.set(&quot;myProperty&quot;, &quot;myValue&quot;);
 *     &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;p&gt;&lt;b&gt;&lt;u&gt;Setting Indexed Properties&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;
 *    &lt;p&gt;If the property &lt;b&gt;doesn't&lt;/b&gt; exist, the &lt;code&gt;LazyDynaBean&lt;/code&gt; will automatically add
 *       a property with an &lt;code&gt;ArrayList&lt;/code&gt; type to the &lt;code&gt;DynaClass&lt;/code&gt; when
 *       the &lt;code&gt;set(name, index, value)&lt;/code&gt; method is called.
 *       It will also instantiate a new &lt;code&gt;ArrayList&lt;/code&gt; and automatically &lt;i&gt;grow&lt;/i&gt;
 *       the &lt;code&gt;List&lt;/code&gt; so that it is big enough to accomodate the index being set.
 *       &lt;code&gt;ArrayList&lt;/code&gt; is the default indexed property that LazyDynaBean uses but
 *       this can be easily changed by overriding the &lt;code&gt;defaultIndexedProperty(name)&lt;/code&gt;
 *       method.&lt;/p&gt;
 *
 *     &lt;pre&gt;&lt;code&gt;
 *         DynaBean myBean = new LazyDynaBean();
 *         myBean.set(&quot;myIndexedProperty&quot;, 0, &quot;myValue1&quot;);
 *         myBean.set(&quot;myIndexedProperty&quot;, 1, &quot;myValue2&quot;);
 *     &lt;/code&gt;&lt;/pre&gt;
 *
 *    &lt;p&gt;If the indexed property &lt;b&gt;does&lt;/b&gt; exist in the &lt;code&gt;DynaClass&lt;/code&gt; but is set to
 *      &lt;code&gt;null&lt;/code&gt; in the &lt;code&gt;LazyDynaBean&lt;/code&gt;, then it will instantiate a
 *      new &lt;code&gt;List&lt;/code&gt; or &lt;code&gt;Array&lt;/code&gt; as specified by the property's type
 *      in the &lt;code&gt;DynaClass&lt;/code&gt; and automatically &lt;i&gt;grow&lt;/i&gt; the &lt;code&gt;List&lt;/code&gt;
 *      or &lt;code&gt;Array&lt;/code&gt; so that it is big enough to accomodate the index being set.&lt;/p&gt;
 *
 *     &lt;pre&gt;&lt;code&gt;
 *         DynaBean myBean = new LazyDynaBean();
 *         MutableDynaClass myClass = (MutableDynaClass)myBean.getDynaClass();
 *         myClass.add(&quot;myIndexedProperty&quot;, int[].class);
 *         myBean.set(&quot;myIndexedProperty&quot;, 0, new Integer(10));
 *         myBean.set(&quot;myIndexedProperty&quot;, 1, new Integer(20));
 *     &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;p&gt;&lt;b&gt;&lt;u&gt;Setting Mapped Properties&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;
 *    &lt;p&gt;If the property &lt;b&gt;doesn't&lt;/b&gt; exist, the &lt;code&gt;LazyDynaBean&lt;/code&gt; will automatically add
 *       a property with a &lt;code&gt;HashMap&lt;/code&gt; type to the &lt;code&gt;DynaClass&lt;/code&gt; and
 *       instantiate a new &lt;code&gt;HashMap&lt;/code&gt; in the DynaBean when the
 *       &lt;code&gt;set(name, key, value)&lt;/code&gt; method is called. &lt;code&gt;HashMap&lt;/code&gt; is the default
 *       mapped property that LazyDynaBean uses but this can be easily changed by overriding
 *       the &lt;code&gt;defaultMappedProperty(name)&lt;/code&gt; method.&lt;/p&gt;
 *
 *     &lt;pre&gt;&lt;code&gt;
 *         DynaBean myBean = new LazyDynaBean();
 *         myBean.set(&quot;myMappedProperty&quot;, &quot;myKey&quot;, &quot;myValue&quot;);
 *     &lt;/code&gt;&lt;/pre&gt;
 *
 *    &lt;p&gt;If the mapped property &lt;b&gt;does&lt;/b&gt; exist in the &lt;code&gt;DynaClass&lt;/code&gt; but is set to
 *      &lt;code&gt;null&lt;/code&gt; in the &lt;code&gt;LazyDynaBean&lt;/code&gt;, then it will instantiate a
 *      new &lt;code&gt;Map&lt;/code&gt; as specified by the property's type in the &lt;code&gt;DynaClass&lt;/code&gt;.&lt;/p&gt;
 *
 *     &lt;pre&gt;&lt;code&gt;
 *         DynaBean myBean = new LazyDynaBean();
 *         MutableDynaClass myClass = (MutableDynaClass)myBean.getDynaClass();
 *         myClass.add(&quot;myMappedProperty&quot;, TreeMap.class);
 *         myBean.set(&quot;myMappedProperty&quot;, &quot;myKey&quot;, &quot;myValue&quot;);
 *     &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;p&gt;&lt;b&gt;&lt;u&gt;&lt;i&gt;Restricted&lt;/i&gt; DynaClass&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;
 *    &lt;p&gt;&lt;code&gt;MutableDynaClass&lt;/code&gt; have a facility to &lt;i&gt;restrict&lt;/i&gt; the &lt;code&gt;DynaClass&lt;/code&gt;
 *       so that its properties cannot be modified. If the &lt;code&gt;MutableDynaClass&lt;/code&gt; is
 *       restricted then calling any of the &lt;code&gt;set()&lt;/code&gt; methods for a property which
 *       doesn't exist will result in a &lt;code&gt;IllegalArgumentException&lt;/code&gt; being thrown.&lt;/p&gt;
 *
 * @version $Id$
 * @see LazyDynaClass
 */
public class LazyDynaBean implements DynaBean, Serializable {

    private static final long serialVersionUID = 1L;

 /**
    * Commons Logging
    */
<span class="fc" id="L131">    private transient Log logger = LogFactory.getLog(LazyDynaBean.class);</span>

    /** BigInteger Zero */
<span class="fc" id="L134">    protected static final BigInteger BigInteger_ZERO = new BigInteger(&quot;0&quot;);</span>
    /** BigDecimal Zero */
<span class="fc" id="L136">    protected static final BigDecimal BigDecimal_ZERO = new BigDecimal(&quot;0&quot;);</span>
    /** Character Space */
<span class="fc" id="L138">    protected static final Character  Character_SPACE = Character.valueOf(' ');</span>
    /** Byte Zero */
<span class="fc" id="L140">    protected static final Byte       Byte_ZERO       = Byte.valueOf((byte)0);</span>
    /** Short Zero */
<span class="fc" id="L142">    protected static final Short      Short_ZERO      = Short.valueOf((short)0);</span>
    /** Integer Zero */
<span class="fc" id="L144">    protected static final Integer    Integer_ZERO    = Integer.valueOf(0);</span>
    /** Long Zero */
<span class="fc" id="L146">    protected static final Long       Long_ZERO       = Long.valueOf(0);</span>
    /** Float Zero */
<span class="fc" id="L148">    protected static final Float      Float_ZERO      = Float.valueOf((byte)0);</span>
    /** Double Zero */
<span class="fc" id="L150">    protected static final Double     Double_ZERO     = Double.valueOf((byte)0);</span>

    /**
     * The &lt;code&gt;MutableDynaClass&lt;/code&gt; &quot;base class&quot; that this DynaBean
     * is associated with.
     */
    protected Map&lt;String, Object&gt; values;

    /** Map decorator for this DynaBean */
    private transient Map&lt;String, Object&gt; mapDecorator;

    /**
     * The &lt;code&gt;MutableDynaClass&lt;/code&gt; &quot;base class&quot; that this DynaBean
     * is associated with.
     */
    protected MutableDynaClass dynaClass;


    // ------------------- Constructors ----------------------------------

    /**
     * Construct a new &lt;code&gt;LazyDynaBean&lt;/code&gt; with a &lt;code&gt;LazyDynaClass&lt;/code&gt; instance.
     */
    public LazyDynaBean() {
<span class="fc" id="L174">        this(new LazyDynaClass());</span>
<span class="fc" id="L175">    }</span>

    /**
     * Construct a new &lt;code&gt;LazyDynaBean&lt;/code&gt; with a &lt;code&gt;LazyDynaClass&lt;/code&gt; instance.
     *
     * @param name Name of this DynaBean class
     */
    public LazyDynaBean(final String name) {
<span class="nc" id="L183">        this(new LazyDynaClass(name));</span>
<span class="nc" id="L184">    }</span>

    /**
     * Construct a new &lt;code&gt;DynaBean&lt;/code&gt; associated with the specified
     * &lt;code&gt;DynaClass&lt;/code&gt; instance - if its not a &lt;code&gt;MutableDynaClass&lt;/code&gt;
     * then a new &lt;code&gt;LazyDynaClass&lt;/code&gt; is created and the properties copied.
     *
     * @param dynaClass The DynaClass we are associated with
     */
<span class="fc" id="L193">    public LazyDynaBean(final DynaClass dynaClass) {</span>

<span class="fc" id="L195">        values = newMap();</span>

<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        if (dynaClass instanceof MutableDynaClass) {</span>
<span class="fc" id="L198">            this.dynaClass = (MutableDynaClass)dynaClass;</span>
        } else {
<span class="nc" id="L200">            this.dynaClass = new LazyDynaClass(dynaClass.getName(), dynaClass.getDynaProperties());</span>
        }

<span class="fc" id="L203">    }</span>


    // ------------------- Public Methods ----------------------------------

    /**
     * &lt;p&gt;
     * Return a Map representation of this DynaBean.
     * &lt;/p&gt;
     * This, for example, could be used in JSTL in the following way to access
     * a DynaBean's &lt;code&gt;fooProperty&lt;/code&gt;:
     * &lt;ul&gt;&lt;li&gt;&lt;code&gt;${myDynaBean.&lt;b&gt;map&lt;/b&gt;.fooProperty}&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;
     *
     * @return a Map representation of this DynaBean
     */
    public Map&lt;String, Object&gt; getMap() {
        // cache the Map
<span class="nc bnc" id="L220" title="All 2 branches missed.">        if (mapDecorator == null) {</span>
<span class="nc" id="L221">            mapDecorator = new DynaBeanPropertyMapDecorator(this);</span>
        }
<span class="nc" id="L223">        return mapDecorator;</span>
    }

    /**
     * &lt;p&gt;Return the size of an indexed or mapped property.&lt;/p&gt;
     *
     * @param name Name of the property
     * @return The indexed or mapped property size
     * @throws IllegalArgumentException if no property name is specified
     */
    public int size(final String name) {

<span class="nc bnc" id="L235" title="All 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L236">            throw new IllegalArgumentException(&quot;No property name specified&quot;);</span>
        }

<span class="nc" id="L239">        final Object value = values.get(name);</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L241">            return 0;</span>
        }

<span class="nc bnc" id="L244" title="All 2 branches missed.">        if (value instanceof Map) {</span>
<span class="nc" id="L245">            return ((Map&lt;?, ?&gt;)value).size();</span>
        }

<span class="nc bnc" id="L248" title="All 2 branches missed.">        if (value instanceof List) {</span>
<span class="nc" id="L249">            return ((List&lt;?&gt;)value).size();</span>
        }

<span class="nc bnc" id="L252" title="All 2 branches missed.">        if (value.getClass().isArray()) {</span>
<span class="nc" id="L253">            return Array.getLength(value);</span>
        }

<span class="nc" id="L256">        return 0;</span>

    }

    // ------------------- DynaBean Methods ----------------------------------

    /**
     * Does the specified mapped property contain a value for the specified
     * key value?
     *
     * @param name Name of the property to check
     * @param key Name of the key to check
     * @return &lt;code&gt;true&lt;/code&gt; if the mapped property contains a value for
     * the specified key, otherwise &lt;code&gt;false&lt;/code&gt;
     *
     * @throws IllegalArgumentException if no property name is specified
     */
    @Override
    public boolean contains(final String name, final String key) {

<span class="nc bnc" id="L276" title="All 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L277">            throw new IllegalArgumentException(&quot;No property name specified&quot;);</span>
        }

<span class="nc" id="L280">        final Object value = values.get(name);</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L282">            return false;</span>
        }

<span class="nc bnc" id="L285" title="All 2 branches missed.">        if (value instanceof Map) {</span>
<span class="nc" id="L286">            return ((Map&lt;?, ?&gt;) value).containsKey(key);</span>
        }

<span class="nc" id="L289">        return false;</span>

    }

    /**
     * &lt;p&gt;Return the value of a simple property with the specified name.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;strong&gt;N.B.&lt;/strong&gt; Returns &lt;code&gt;null&lt;/code&gt; if there is no property
     *  of the specified name.&lt;/p&gt;
     *
     * @param name Name of the property whose value is to be retrieved.
     * @return The property's value
     * @throws IllegalArgumentException if no property name is specified
     */
    @Override
    public Object get(final String name) {

<span class="pc bpc" id="L306" title="1 of 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L307">            throw new IllegalArgumentException(&quot;No property name specified&quot;);</span>
        }

        // Value found
<span class="fc" id="L311">        Object value = values.get(name);</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">        if (value != null) {</span>
<span class="fc" id="L313">            return value;</span>
        }

        // Property doesn't exist
<span class="fc bfc" id="L317" title="All 2 branches covered.">        if (!isDynaProperty(name)) {</span>
<span class="fc" id="L318">            return null;</span>
        }

        // Property doesn't exist
<span class="fc" id="L322">        value = createProperty(name, dynaClass.getDynaProperty(name).getType());</span>

<span class="fc bfc" id="L324" title="All 2 branches covered.">        if (value != null) {</span>
<span class="fc" id="L325">            set(name, value);</span>
        }

<span class="fc" id="L328">        return value;</span>

    }

    /**
     * &lt;p&gt;Return the value of an indexed property with the specified name.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;strong&gt;N.B.&lt;/strong&gt; Returns &lt;code&gt;null&lt;/code&gt; if there is no 'indexed'
     * property of the specified name.&lt;/p&gt;
     *
     * @param name Name of the property whose value is to be retrieved
     * @param index Index of the value to be retrieved
     * @return The indexed property's value
     *
     * @throws IllegalArgumentException if the specified property
     *  exists, but is not indexed
     * @throws IndexOutOfBoundsException if the specified index
     *  is outside the range of the underlying property
     */
    @Override
    public Object get(final String name, final int index) {

        // If its not a property, then create default indexed property
<span class="fc bfc" id="L351" title="All 2 branches covered.">        if (!isDynaProperty(name)) {</span>
<span class="fc" id="L352">            set(name, defaultIndexedProperty(name));</span>
        }

        // Get the indexed property
<span class="fc" id="L356">        Object indexedProperty = get(name);</span>

        // Check that the property is indexed
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">        if (!dynaClass.getDynaProperty(name).isIndexed()) {</span>
<span class="nc" id="L360">            throw new IllegalArgumentException</span>
                (&quot;Non-indexed property for '&quot; + name + &quot;[&quot; + index + &quot;]' &quot;
<span class="nc" id="L362">                                      + dynaClass.getDynaProperty(name).getName());</span>
        }

        // Grow indexed property to appropriate size
<span class="fc" id="L366">        indexedProperty = growIndexedProperty(name, indexedProperty, index);</span>

        // Return the indexed value
<span class="fc bfc" id="L369" title="All 2 branches covered.">        if (indexedProperty.getClass().isArray()) {</span>
<span class="fc" id="L370">            return Array.get(indexedProperty, index);</span>
<span class="pc bpc" id="L371" title="1 of 2 branches missed.">        } else if (indexedProperty instanceof List) {</span>
<span class="fc" id="L372">            return ((List&lt;?&gt;)indexedProperty).get(index);</span>
        } else {
<span class="nc" id="L374">            throw new IllegalArgumentException</span>
                (&quot;Non-indexed property for '&quot; + name + &quot;[&quot; + index + &quot;]' &quot;
<span class="nc" id="L376">                                  + indexedProperty.getClass().getName());</span>
        }

    }

    /**
     * &lt;p&gt;Return the value of a mapped property with the specified name.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;strong&gt;N.B.&lt;/strong&gt; Returns &lt;code&gt;null&lt;/code&gt; if there is no 'mapped'
     * property of the specified name.&lt;/p&gt;
     *
     * @param name Name of the property whose value is to be retrieved
     * @param key Key of the value to be retrieved
     * @return The mapped property's value
     *
     * @throws IllegalArgumentException if the specified property
     *  exists, but is not mapped
     */
    @Override
    public Object get(final String name, final String key) {

        // If its not a property, then create default mapped property
<span class="fc bfc" id="L398" title="All 2 branches covered.">        if (!isDynaProperty(name)) {</span>
<span class="fc" id="L399">            set(name, defaultMappedProperty(name));</span>
        }

        // Get the mapped property
<span class="fc" id="L403">        final Object mappedProperty = get(name);</span>

        // Check that the property is mapped
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">        if (!dynaClass.getDynaProperty(name).isMapped()) {</span>
<span class="nc" id="L407">            throw new IllegalArgumentException</span>
                (&quot;Non-mapped property for '&quot; + name + &quot;(&quot; + key + &quot;)' &quot;
<span class="nc" id="L409">                            + dynaClass.getDynaProperty(name).getType().getName());</span>
        }

        // Get the value from the Map
<span class="pc bpc" id="L413" title="1 of 2 branches missed.">        if (mappedProperty instanceof Map) {</span>
<span class="fc" id="L414">            return ((Map&lt;?, ?&gt;) mappedProperty).get(key);</span>
        }
<span class="nc" id="L416">        throw new IllegalArgumentException</span>
          (&quot;Non-mapped property for '&quot; + name + &quot;(&quot; + key + &quot;)'&quot;
<span class="nc" id="L418">                              + mappedProperty.getClass().getName());</span>

    }


    /**
     * Return the &lt;code&gt;DynaClass&lt;/code&gt; instance that describes the set of
     * properties available for this DynaBean.
     *
     * @return The associated DynaClass
     */
    @Override
    public DynaClass getDynaClass() {
<span class="fc" id="L431">        return dynaClass;</span>
    }

    /**
     * Remove any existing value for the specified key on the
     * specified mapped property.
     *
     * @param name Name of the property for which a value is to
     *  be removed
     * @param key Key of the value to be removed
     *
     * @throws IllegalArgumentException if there is no property
     *  of the specified name
     */
    @Override
    public void remove(final String name, final String key) {

<span class="nc bnc" id="L448" title="All 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L449">            throw new IllegalArgumentException(&quot;No property name specified&quot;);</span>
        }

<span class="nc" id="L452">        final Object value = values.get(name);</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L454">            return;</span>
        }

<span class="nc bnc" id="L457" title="All 2 branches missed.">        if (value instanceof Map) {</span>
<span class="nc" id="L458">            ((Map&lt;?, ?&gt;) value).remove(key);</span>
        } else {
<span class="nc" id="L460">            throw new IllegalArgumentException</span>
                    (&quot;Non-mapped property for '&quot; + name + &quot;(&quot; + key + &quot;)'&quot;
<span class="nc" id="L462">                            + value.getClass().getName());</span>
        }

<span class="nc" id="L465">    }</span>

    /**
     * Set the value of a simple property with the specified name.
     *
     * @param name Name of the property whose value is to be set
     * @param value Value to which this property is to be set
     *
     * @throws IllegalArgumentException if this is not an existing property
     *  name for our DynaClass and the MutableDynaClass is restricted
     * @throws ConversionException if the specified value cannot be
     *  converted to the type required for this property
     * @throws NullPointerException if an attempt is made to set a
     *  primitive property to null
     */
    @Override
    public void set(final String name, final Object value) {

        // If the property doesn't exist, then add it
<span class="fc bfc" id="L484" title="All 2 branches covered.">        if (!isDynaProperty(name)) {</span>

<span class="fc bfc" id="L486" title="All 2 branches covered.">            if (dynaClass.isRestricted()) {</span>
<span class="fc" id="L487">                throw new IllegalArgumentException</span>
                    (&quot;Invalid property name '&quot; + name + &quot;' (DynaClass is restricted)&quot;);
            }
<span class="fc bfc" id="L490" title="All 2 branches covered.">            if (value == null) {</span>
<span class="fc" id="L491">                dynaClass.add(name);</span>
            } else {
<span class="fc" id="L493">                dynaClass.add(name, value.getClass());</span>
            }

        }

<span class="fc" id="L498">        final DynaProperty descriptor = dynaClass.getDynaProperty(name);</span>

<span class="fc bfc" id="L500" title="All 2 branches covered.">        if (value == null) {</span>
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">            if (descriptor.getType().isPrimitive()) {</span>
<span class="nc" id="L502">                throw new NullPointerException</span>
                        (&quot;Primitive value for '&quot; + name + &quot;'&quot;);
            }
<span class="fc bfc" id="L505" title="All 2 branches covered.">        } else if (!isAssignable(descriptor.getType(), value.getClass())) {</span>
<span class="fc" id="L506">            throw new ConversionException</span>
                    (&quot;Cannot assign value of type '&quot; +
<span class="fc" id="L508">                    value.getClass().getName() +</span>
                    &quot;' to property '&quot; + name + &quot;' of type '&quot; +
<span class="fc" id="L510">                    descriptor.getType().getName() + &quot;'&quot;);</span>
        }

        // Set the property's value
<span class="fc" id="L514">        values.put(name, value);</span>

<span class="fc" id="L516">    }</span>

    /**
     * Set the value of an indexed property with the specified name.
     *
     * @param name Name of the property whose value is to be set
     * @param index Index of the property to be set
     * @param value Value to which this property is to be set
     *
     * @throws ConversionException if the specified value cannot be
     *  converted to the type required for this property
     * @throws IllegalArgumentException if there is no property
     *  of the specified name
     * @throws IllegalArgumentException if the specified property
     *  exists, but is not indexed
     * @throws IndexOutOfBoundsException if the specified index
     *  is outside the range of the underlying property
     */
    @Override
    public void set(final String name, final int index, final Object value) {

        // If its not a property, then create default indexed property
<span class="fc bfc" id="L538" title="All 2 branches covered.">        if (!isDynaProperty(name)) {</span>
<span class="fc" id="L539">            set(name, defaultIndexedProperty(name));</span>
        }

        // Get the indexed property
<span class="fc" id="L543">        Object indexedProperty = get(name);</span>

        // Check that the property is indexed
<span class="fc bfc" id="L546" title="All 2 branches covered.">        if (!dynaClass.getDynaProperty(name).isIndexed()) {</span>
<span class="fc" id="L547">            throw new IllegalArgumentException</span>
                (&quot;Non-indexed property for '&quot; + name + &quot;[&quot; + index + &quot;]'&quot;
<span class="fc" id="L549">                            + dynaClass.getDynaProperty(name).getType().getName());</span>
        }

        // Grow indexed property to appropriate size
<span class="fc" id="L553">        indexedProperty = growIndexedProperty(name, indexedProperty, index);</span>

        // Set the value in an array
<span class="fc bfc" id="L556" title="All 2 branches covered.">        if (indexedProperty.getClass().isArray()) {</span>
<span class="fc" id="L557">            Array.set(indexedProperty, index, value);</span>
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">        } else if (indexedProperty instanceof List) {</span>
            @SuppressWarnings(&quot;unchecked&quot;)
            final
            // Indexed properties are stored in a List&lt;Object&gt;
<span class="fc" id="L562">            List&lt;Object&gt; values = (List&lt;Object&gt;) indexedProperty;</span>
<span class="fc" id="L563">            values.set(index, value);</span>
<span class="fc" id="L564">        } else {</span>
<span class="nc" id="L565">            throw new IllegalArgumentException</span>
                (&quot;Non-indexed property for '&quot; + name + &quot;[&quot; + index + &quot;]' &quot;
<span class="nc" id="L567">                            + indexedProperty.getClass().getName());</span>
        }

<span class="fc" id="L570">    }</span>

    /**
     * Set the value of a mapped property with the specified name.
     *
     * @param name Name of the property whose value is to be set
     * @param key Key of the property to be set
     * @param value Value to which this property is to be set
     *
     * @throws ConversionException if the specified value cannot be
     *  converted to the type required for this property
     * @throws IllegalArgumentException if there is no property
     *  of the specified name
     * @throws IllegalArgumentException if the specified property
     *  exists, but is not mapped
     */
    @Override
    public void set(final String name, final String key, final Object value) {

        // If the 'mapped' property doesn't exist, then add it
<span class="fc bfc" id="L590" title="All 2 branches covered.">        if (!isDynaProperty(name)) {</span>
<span class="nc" id="L591">            set(name, defaultMappedProperty(name));</span>
        }

        // Get the mapped property
<span class="fc" id="L595">        final Object mappedProperty = get(name);</span>

        // Check that the property is mapped
<span class="fc bfc" id="L598" title="All 2 branches covered.">        if (!dynaClass.getDynaProperty(name).isMapped()) {</span>
<span class="fc" id="L599">            throw new IllegalArgumentException</span>
                (&quot;Non-mapped property for '&quot; + name + &quot;(&quot; + key + &quot;)'&quot;
<span class="fc" id="L601">                            + dynaClass.getDynaProperty(name).getType().getName());</span>
        }

        // Set the value in the Map
        @SuppressWarnings(&quot;unchecked&quot;)
        final
        // mapped properties are stored in a Map&lt;String, Object&gt;
<span class="fc" id="L608">        Map&lt;String, Object&gt; valuesMap = (Map&lt;String, Object&gt;) mappedProperty;</span>
<span class="fc" id="L609">        valuesMap.put(key, value);</span>

<span class="fc" id="L611">    }</span>

    // ------------------- protected Methods ----------------------------------

    /**
     * Grow the size of an indexed property
     * @param name The name of the property
     * @param indexedProperty The current property value
     * @param index The indexed value to grow the property to (i.e. one less than
     * the required size)
     * @return The new property value (grown to the appropriate size)
     */
    protected Object growIndexedProperty(final String name, Object indexedProperty, final int index) {

        // Grow a List to the appropriate size
<span class="fc bfc" id="L626" title="All 2 branches covered.">        if (indexedProperty instanceof List) {</span>

            @SuppressWarnings(&quot;unchecked&quot;)
            final
            // Indexed properties are stored as List&lt;Object&gt;
<span class="fc" id="L631">            List&lt;Object&gt; list = (List&lt;Object&gt;)indexedProperty;</span>
<span class="fc bfc" id="L632" title="All 2 branches covered.">            while (index &gt;= list.size()) {</span>
<span class="fc" id="L633">                final Class&lt;?&gt; contentType = getDynaClass().getDynaProperty(name).getContentType();</span>
<span class="fc" id="L634">                Object value = null;</span>
<span class="pc bpc" id="L635" title="1 of 2 branches missed.">                if (contentType != null) {</span>
<span class="nc" id="L636">                    value = createProperty(name+&quot;[&quot;+list.size()+&quot;]&quot;, contentType);</span>
                }
<span class="fc" id="L638">                list.add(value);</span>
<span class="fc" id="L639">            }</span>

        }

        // Grow an Array to the appropriate size
<span class="fc bfc" id="L644" title="All 2 branches covered.">        if (indexedProperty.getClass().isArray()) {</span>

<span class="fc" id="L646">            final int length = Array.getLength(indexedProperty);</span>
<span class="fc bfc" id="L647" title="All 2 branches covered.">            if (index &gt;= length) {</span>
<span class="fc" id="L648">                final Class&lt;?&gt; componentType = indexedProperty.getClass().getComponentType();</span>
<span class="fc" id="L649">                final Object newArray = Array.newInstance(componentType, index + 1);</span>
<span class="fc" id="L650">                System.arraycopy(indexedProperty, 0, newArray, 0, length);</span>
<span class="fc" id="L651">                indexedProperty = newArray;</span>
<span class="fc" id="L652">                set(name, indexedProperty);</span>
<span class="fc" id="L653">                final int newLength = Array.getLength(indexedProperty);</span>
<span class="fc bfc" id="L654" title="All 2 branches covered.">                for (int i = length; i &lt; newLength; i++) {</span>
<span class="fc" id="L655">                    Array.set(indexedProperty, i, createProperty(name+&quot;[&quot;+i+&quot;]&quot;, componentType));</span>
                }
            }
        }

<span class="fc" id="L660">        return indexedProperty;</span>

    }

    /**
     * Create a new Instance of a Property
     * @param name The name of the property
     * @param type The class of the property
     * @return The new value
     */
    protected Object createProperty(final String name, final Class&lt;?&gt; type) {
<span class="pc bpc" id="L671" title="1 of 2 branches missed.">        if (type == null) {</span>
<span class="nc" id="L672">            return null;</span>
        }

        // Create Lists, arrays or DynaBeans
<span class="fc bfc" id="L676" title="All 4 branches covered.">        if (type.isArray() || List.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L677">            return createIndexedProperty(name, type);</span>
        }

<span class="fc bfc" id="L680" title="All 2 branches covered.">        if (Map.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L681">            return createMappedProperty(name, type);</span>
        }

<span class="fc bfc" id="L684" title="All 2 branches covered.">        if (DynaBean.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L685">            return createDynaBeanProperty(name, type);</span>
        }

<span class="fc bfc" id="L688" title="All 2 branches covered.">        if (type.isPrimitive()) {</span>
<span class="fc" id="L689">            return createPrimitiveProperty(name, type);</span>
        }

<span class="pc bpc" id="L692" title="1 of 2 branches missed.">        if (Number.class.isAssignableFrom(type)) {</span>
<span class="nc" id="L693">            return createNumberProperty(name, type);</span>
        }

<span class="fc" id="L696">        return createOtherProperty(name, type);</span>

    }

    /**
     * Create a new Instance of an 'Indexed' Property
     * @param name The name of the property
     * @param type The class of the property
     * @return The new value
     */
    protected Object createIndexedProperty(final String name, final Class&lt;?&gt; type) {

        // Create the indexed object
<span class="fc" id="L709">        Object indexedProperty = null;</span>

<span class="pc bpc" id="L711" title="1 of 2 branches missed.">        if (type == null) {</span>

<span class="nc" id="L713">            indexedProperty = defaultIndexedProperty(name);</span>

<span class="fc bfc" id="L715" title="All 2 branches covered.">        } else if (type.isArray()) {</span>

<span class="fc" id="L717">            indexedProperty = Array.newInstance(type.getComponentType(), 0);</span>

<span class="pc bpc" id="L719" title="1 of 2 branches missed.">        } else if (List.class.isAssignableFrom(type)) {</span>
<span class="pc bpc" id="L720" title="1 of 2 branches missed.">            if (type.isInterface()) {</span>
<span class="nc" id="L721">                indexedProperty = defaultIndexedProperty(name);</span>
            } else {
                try {
<span class="fc" id="L724">                    indexedProperty = type.newInstance();</span>
                }
<span class="nc" id="L726">                catch (final Exception ex) {</span>
<span class="nc" id="L727">                    throw new IllegalArgumentException</span>
                        (&quot;Error instantiating indexed property of type '&quot; +
<span class="nc" id="L729">                                   type.getName() + &quot;' for '&quot; + name + &quot;' &quot; + ex);</span>
<span class="fc" id="L730">                }</span>
            }
        } else {

<span class="nc" id="L734">            throw new IllegalArgumentException</span>
<span class="nc" id="L735">                    (&quot;Non-indexed property of type '&quot; + type.getName() + &quot;' for '&quot; + name + &quot;'&quot;);</span>
        }

<span class="fc" id="L738">        return indexedProperty;</span>

    }

    /**
     * Create a new Instance of a 'Mapped' Property
     * @param name The name of the property
     * @param type The class of the property
     * @return The new value
     */
    protected Object createMappedProperty(final String name, final Class&lt;?&gt; type) {

        // Create the mapped object
<span class="fc" id="L751">        Object mappedProperty = null;</span>

<span class="pc bpc" id="L753" title="1 of 2 branches missed.">        if (type == null) {</span>

<span class="nc" id="L755">            mappedProperty = defaultMappedProperty(name);</span>

<span class="pc bpc" id="L757" title="1 of 2 branches missed.">        } else if (type.isInterface()) {</span>

<span class="nc" id="L759">            mappedProperty = defaultMappedProperty(name);</span>

<span class="pc bpc" id="L761" title="1 of 2 branches missed.">        } else if (Map.class.isAssignableFrom(type)) {</span>
            try {
<span class="fc" id="L763">                mappedProperty = type.newInstance();</span>
            }
<span class="nc" id="L765">            catch (final Exception ex) {</span>
<span class="nc" id="L766">                throw new IllegalArgumentException</span>
                    (&quot;Error instantiating mapped property of type '&quot; +
<span class="nc" id="L768">                            type.getName() + &quot;' for '&quot; + name + &quot;' &quot; + ex);</span>
<span class="fc" id="L769">            }</span>
        } else {

<span class="nc" id="L772">            throw new IllegalArgumentException</span>
<span class="nc" id="L773">                    (&quot;Non-mapped property of type '&quot; + type.getName() + &quot;' for '&quot; + name + &quot;'&quot;);</span>
        }

<span class="fc" id="L776">        return mappedProperty;</span>

    }

    /**
     * Create a new Instance of a 'DynaBean' Property.
     * @param name The name of the property
     * @param type The class of the property
     * @return The new value
     */
    protected Object createDynaBeanProperty(final String name, final Class&lt;?&gt; type) {
        try {
<span class="fc" id="L788">            return type.newInstance();</span>
        }
<span class="nc" id="L790">        catch (final Exception ex) {</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">            if (logger().isWarnEnabled()) {</span>
<span class="nc" id="L792">                logger().warn(&quot;Error instantiating DynaBean property of type '&quot; +</span>
<span class="nc" id="L793">                        type.getName() + &quot;' for '&quot; + name + &quot;' &quot; + ex);</span>
            }
<span class="nc" id="L795">            return null;</span>
        }
    }

    /**
     * Create a new Instance of a 'Primitive' Property.
     * @param name The name of the property
     * @param type The class of the property
     * @return The new value
     */
    protected Object createPrimitiveProperty(final String name, final Class&lt;?&gt; type) {

<span class="pc bpc" id="L807" title="1 of 2 branches missed.">        if (type == Boolean.TYPE) {</span>
<span class="nc" id="L808">            return Boolean.FALSE;</span>
<span class="pc bpc" id="L809" title="1 of 2 branches missed.">        } else if (type == Integer.TYPE) {</span>
<span class="fc" id="L810">            return Integer_ZERO;</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">        } else if (type == Long.TYPE) {</span>
<span class="nc" id="L812">            return Long_ZERO;</span>
<span class="nc bnc" id="L813" title="All 2 branches missed.">        } else if (type == Double.TYPE) {</span>
<span class="nc" id="L814">            return Double_ZERO;</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">        } else if (type == Float.TYPE) {</span>
<span class="nc" id="L816">            return Float_ZERO;</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">        } else if (type == Byte.TYPE) {</span>
<span class="nc" id="L818">            return Byte_ZERO;</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">        } else if (type == Short.TYPE) {</span>
<span class="nc" id="L820">            return Short_ZERO;</span>
<span class="nc bnc" id="L821" title="All 2 branches missed.">        } else if (type == Character.TYPE) {</span>
<span class="nc" id="L822">            return Character_SPACE;</span>
        } else {
<span class="nc" id="L824">            return null;</span>
        }

    }

    /**
     * Create a new Instance of a &lt;code&gt;java.lang.Number&lt;/code&gt; Property.
     * @param name The name of the property
     * @param type The class of the property
     * @return The new value
     */
    protected Object createNumberProperty(final String name, final Class&lt;?&gt; type) {

<span class="nc" id="L837">        return null;</span>

    }

    /**
     * Create a new Instance of other Property types
     * @param name The name of the property
     * @param type The class of the property
     * @return The new value
     */
    protected Object createOtherProperty(final String name, final Class&lt;?&gt; type) {

<span class="pc bpc" id="L849" title="5 of 8 branches missed.">        if (type == Object.class    ||</span>
            type == String.class    ||
            type == Boolean.class   ||
            type == Character.class ||
<span class="nc bnc" id="L853" title="All 2 branches missed.">            Date.class.isAssignableFrom(type)) {</span>

<span class="fc" id="L855">            return null;</span>

        }

        try {
<span class="nc" id="L860">            return type.newInstance();</span>
        }
<span class="nc" id="L862">        catch (final Exception ex) {</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">            if (logger().isWarnEnabled()) {</span>
<span class="nc" id="L864">                logger().warn(&quot;Error instantiating property of type '&quot; + type.getName() + &quot;' for '&quot; + name + &quot;' &quot; + ex);</span>
            }
<span class="nc" id="L866">            return null;</span>
        }
    }

    /**
     * &lt;p&gt;Creates a new &lt;code&gt;ArrayList&lt;/code&gt; for an 'indexed' property
     *    which doesn't exist.&lt;/p&gt;
     *
     * &lt;p&gt;This method should be overridden if an alternative &lt;code&gt;List&lt;/code&gt;
     *    or &lt;code&gt;Array&lt;/code&gt; implementation is required for 'indexed' properties.&lt;/p&gt;
     *
     * @param name Name of the 'indexed property.
     * @return The default value for an indexed property (java.util.ArrayList)
     */
    protected Object defaultIndexedProperty(final String name) {
<span class="fc" id="L881">        return new ArrayList&lt;&gt;();</span>
    }

    /**
     * &lt;p&gt;Creates a new &lt;code&gt;HashMap&lt;/code&gt; for a 'mapped' property
     *    which doesn't exist.&lt;/p&gt;
     *
     * &lt;p&gt;This method can be overridden if an alternative &lt;code&gt;Map&lt;/code&gt;
     *    implementation is required for 'mapped' properties.&lt;/p&gt;
     *
     * @param name Name of the 'mapped property.
     * @return The default value for a mapped property (java.util.HashMap)
     */
    protected Map&lt;String, Object&gt; defaultMappedProperty(final String name) {
<span class="fc" id="L895">        return new HashMap&lt;&gt;();</span>
    }

    /**
     * Indicates if there is a property with the specified name.
     * @param name The name of the property to check
     * @return &lt;code&gt;true&lt;/code&gt; if there is a property of the
     * specified name, otherwise &lt;code&gt;false&lt;/code&gt;
     */
    protected boolean isDynaProperty(final String name) {

<span class="pc bpc" id="L906" title="1 of 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L907">            throw new IllegalArgumentException(&quot;No property name specified&quot;);</span>
        }

        // Handle LazyDynaClasses
<span class="pc bpc" id="L911" title="1 of 2 branches missed.">        if (dynaClass instanceof LazyDynaClass) {</span>
<span class="fc" id="L912">            return ((LazyDynaClass)dynaClass).isDynaProperty(name);</span>
        }

        // Handle other MutableDynaClass
<span class="nc bnc" id="L916" title="All 2 branches missed.">        return dynaClass.getDynaProperty(name) == null ? false : true;</span>

    }

    /**
     * Is an object of the source class assignable to the destination class?
     *
     * @param dest Destination class
     * @param source Source class
     * @return &lt;code&gt;true&lt;/code&gt; if the source class is assignable to the
     * destination class, otherwise &lt;code&gt;false&lt;/code&gt;
     */
    protected boolean isAssignable(final Class&lt;?&gt; dest, final Class&lt;?&gt; source) {

<span class="pc bpc" id="L930" title="24 of 34 branches missed.">        if (dest.isAssignableFrom(source) ||</span>
                dest == Boolean.TYPE &amp;&amp; source == Boolean.class ||
                dest == Byte.TYPE &amp;&amp; source == Byte.class ||
                dest == Character.TYPE &amp;&amp; source == Character.class ||
                dest == Double.TYPE &amp;&amp; source == Double.class ||
                dest == Float.TYPE &amp;&amp; source == Float.class ||
                dest == Integer.TYPE &amp;&amp; source == Integer.class ||
                dest == Long.TYPE &amp;&amp; source == Long.class ||
                dest == Short.TYPE &amp;&amp; source == Short.class) {
<span class="fc" id="L939">            return true;</span>
        }
<span class="fc" id="L941">        return false;</span>

    }

    /**
     * &lt;p&gt;Creates a new instance of the &lt;code&gt;Map&lt;/code&gt;.&lt;/p&gt;
     * @return a new Map instance
     */
    protected Map&lt;String, Object&gt; newMap() {
<span class="fc" id="L950">        return new HashMap&lt;&gt;();</span>
    }

    /**
     * &lt;p&gt;Returns the &lt;code&gt;Log&lt;/code&gt;.
     */
    private Log logger() {
<span class="nc bnc" id="L957" title="All 2 branches missed.">        if (logger == null) {</span>
<span class="nc" id="L958">            logger = LogFactory.getLog(LazyDynaBean.class);</span>
        }
<span class="nc" id="L960">        return logger;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>