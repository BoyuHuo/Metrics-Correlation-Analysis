<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MappedPropertyDescriptor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons BeanUtils</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.beanutils2</a> &gt; <span class="el_source">MappedPropertyDescriptor.java</span></div><h1>MappedPropertyDescriptor.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.beanutils2;


import java.beans.IntrospectionException;
import java.beans.PropertyDescriptor;
import java.lang.ref.Reference;
import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;


/**
 * A MappedPropertyDescriptor describes one mapped property.
 * Mapped properties are multivalued properties like indexed properties
 * but that are accessed with a String key instead of an index.
 * Such property values are typically stored in a Map collection.
 * For this class to work properly, a mapped value must have
 * getter and setter methods of the form
 * &lt;p&gt;&lt;code&gt;get&lt;strong&gt;Property&lt;/strong&gt;(String key)&lt;/code&gt; and
 * &lt;p&gt;&lt;code&gt;set&lt;strong&gt;Property&lt;/strong&gt;(String key, Object value)&lt;/code&gt;,
 * &lt;p&gt;where &lt;code&gt;&lt;strong&gt;Property&lt;/strong&gt;&lt;/code&gt; must be replaced
 * by the name of the property.
 * @see java.beans.PropertyDescriptor
 *
 * @version $Id$
 */
public class MappedPropertyDescriptor extends PropertyDescriptor {
    // ----------------------------------------------------- Instance Variables

    /**
     * The underlying data type of the property we are describing.
     */
    private Reference&lt;Class&lt;?&gt;&gt; mappedPropertyTypeRef;

    /**
     * The reader method for this property (if any).
     */
    private MappedMethodReference mappedReadMethodRef;

    /**
     * The writer method for this property (if any).
     */
    private MappedMethodReference mappedWriteMethodRef;

    /**
     * The parameter types array for the reader method signature.
     */
<span class="fc" id="L66">    private static final Class&lt;?&gt;[] STRING_CLASS_PARAMETER = new Class[]{String.class};</span>

    // ----------------------------------------------------------- Constructors

    /**
     * Constructs a MappedPropertyDescriptor for a property that follows
     * the standard Java convention by having getFoo and setFoo
     * accessor methods, with the addition of a String parameter (the key).
     * Thus if the argument name is &quot;fred&quot;, it will
     * assume that the writer method is &quot;setFred&quot; and the reader method
     * is &quot;getFred&quot;.  Note that the property name should start with a lower
     * case character, which will be capitalized in the method names.
     *
     * @param propertyName The programmatic name of the property.
     * @param beanClass The Class object for the target bean.  For
     *        example sun.beans.OurButton.class.
     *
     * @throws IntrospectionException if an exception occurs during
     *              introspection.
     */
    public MappedPropertyDescriptor(final String propertyName, final Class&lt;?&gt; beanClass)
            throws IntrospectionException {

<span class="fc" id="L89">        super(propertyName, null, null);</span>

<span class="pc bpc" id="L91" title="2 of 4 branches missed.">        if (propertyName == null || propertyName.length() == 0) {</span>
<span class="nc" id="L92">            throw new IntrospectionException(&quot;bad property name: &quot; +</span>
<span class="nc" id="L93">                    propertyName + &quot; on class: &quot; + beanClass.getClass().getName());</span>
        }

<span class="fc" id="L96">        setName(propertyName);</span>
<span class="fc" id="L97">        final String base = capitalizePropertyName(propertyName);</span>

        // Look for mapped read method and matching write method
<span class="fc" id="L100">        Method mappedReadMethod = null;</span>
<span class="fc" id="L101">        Method mappedWriteMethod = null;</span>
        try {
            try {
<span class="fc" id="L104">                mappedReadMethod = getMethod(beanClass, &quot;get&quot; + base,</span>
                        STRING_CLASS_PARAMETER);
<span class="fc" id="L106">            } catch (final IntrospectionException e) {</span>
<span class="fc" id="L107">                mappedReadMethod = getMethod(beanClass, &quot;is&quot; + base,</span>
                        STRING_CLASS_PARAMETER);
<span class="fc" id="L109">            }</span>
<span class="fc" id="L110">            final Class&lt;?&gt;[] params = { String.class, mappedReadMethod.getReturnType() };</span>
<span class="fc" id="L111">            mappedWriteMethod = getMethod(beanClass, &quot;set&quot; + base, params);</span>
<span class="fc" id="L112">        } catch (final IntrospectionException e) {</span>
            /* Swallow IntrospectionException
             * TODO: Why?
             */
<span class="fc" id="L116">        }</span>

        // If there's no read method, then look for just a write method
<span class="fc bfc" id="L119" title="All 2 branches covered.">        if (mappedReadMethod == null) {</span>
<span class="fc" id="L120">            mappedWriteMethod = getMethod(beanClass, &quot;set&quot; + base, 2);</span>
        }

<span class="pc bpc" id="L123" title="1 of 4 branches missed.">        if (mappedReadMethod == null &amp;&amp; mappedWriteMethod == null) {</span>
<span class="nc" id="L124">            throw new IntrospectionException(&quot;Property '&quot; + propertyName +</span>
                    &quot;' not found on &quot; +
<span class="nc" id="L126">                    beanClass.getName());</span>
        }
<span class="fc" id="L128">        mappedReadMethodRef  = new MappedMethodReference(mappedReadMethod);</span>
<span class="fc" id="L129">        mappedWriteMethodRef = new MappedMethodReference(mappedWriteMethod);</span>

<span class="fc" id="L131">        findMappedPropertyType();</span>
<span class="fc" id="L132">    }</span>


    /**
     * This constructor takes the name of a mapped property, and method
     * names for reading and writing the property.
     *
     * @param propertyName The programmatic name of the property.
     * @param beanClass The Class object for the target bean.  For
     *        example sun.beans.OurButton.class.
     * @param mappedGetterName The name of the method used for
     *          reading one of the property values.  May be null if the
     *          property is write-only.
     * @param mappedSetterName The name of the method used for writing
     *          one of the property values.  May be null if the property is
     *          read-only.
     *
     * @throws IntrospectionException if an exception occurs during
     *              introspection.
     */
    public MappedPropertyDescriptor(final String propertyName, final Class&lt;?&gt; beanClass,
                                    final String mappedGetterName, final String mappedSetterName)
            throws IntrospectionException {

<span class="nc" id="L156">        super(propertyName, null, null);</span>

<span class="nc bnc" id="L158" title="All 4 branches missed.">        if (propertyName == null || propertyName.length() == 0) {</span>
<span class="nc" id="L159">            throw new IntrospectionException(&quot;bad property name: &quot; +</span>
                    propertyName);
        }
<span class="nc" id="L162">        setName(propertyName);</span>

        // search the mapped get and set methods
<span class="nc" id="L165">        Method mappedReadMethod = null;</span>
<span class="nc" id="L166">        Method mappedWriteMethod = null;</span>
<span class="nc" id="L167">        mappedReadMethod =</span>
<span class="nc" id="L168">            getMethod(beanClass, mappedGetterName, STRING_CLASS_PARAMETER);</span>

<span class="nc bnc" id="L170" title="All 2 branches missed.">        if (mappedReadMethod != null) {</span>
<span class="nc" id="L171">            final Class&lt;?&gt;[] params = { String.class, mappedReadMethod.getReturnType() };</span>
<span class="nc" id="L172">            mappedWriteMethod =</span>
<span class="nc" id="L173">                getMethod(beanClass, mappedSetterName, params);</span>
<span class="nc" id="L174">        } else {</span>
<span class="nc" id="L175">            mappedWriteMethod =</span>
<span class="nc" id="L176">                getMethod(beanClass, mappedSetterName, 2);</span>
        }
<span class="nc" id="L178">        mappedReadMethodRef  = new MappedMethodReference(mappedReadMethod);</span>
<span class="nc" id="L179">        mappedWriteMethodRef = new MappedMethodReference(mappedWriteMethod);</span>

<span class="nc" id="L181">        findMappedPropertyType();</span>
<span class="nc" id="L182">    }</span>

    /**
     * This constructor takes the name of a mapped property, and Method
     * objects for reading and writing the property.
     *
     * @param propertyName The programmatic name of the property.
     * @param mappedGetter The method used for reading one of
     *          the property values.  May be be null if the property
     *          is write-only.
     * @param mappedSetter The method used for writing one the
     *          property values.  May be null if the property is read-only.
     *
     * @throws IntrospectionException if an exception occurs during
     *              introspection.
     */
    public MappedPropertyDescriptor(final String propertyName,
                                    final Method mappedGetter, final Method mappedSetter)
            throws IntrospectionException {

<span class="nc" id="L202">        super(propertyName, mappedGetter, mappedSetter);</span>

<span class="nc bnc" id="L204" title="All 4 branches missed.">        if (propertyName == null || propertyName.length() == 0) {</span>
<span class="nc" id="L205">            throw new IntrospectionException(&quot;bad property name: &quot; +</span>
                    propertyName);
        }

<span class="nc" id="L209">        setName(propertyName);</span>
<span class="nc" id="L210">        mappedReadMethodRef  = new MappedMethodReference(mappedGetter);</span>
<span class="nc" id="L211">        mappedWriteMethodRef = new MappedMethodReference(mappedSetter);</span>
<span class="nc" id="L212">        findMappedPropertyType();</span>
<span class="nc" id="L213">    }</span>

    // -------------------------------------------------------- Public Methods

    /**
     * Gets the Class object for the property values.
     *
     * @return The Java type info for the property values.  Note that
     * the &quot;Class&quot; object may describe a built-in Java type such as &quot;int&quot;.
     * The result may be &quot;null&quot; if this is a mapped property that
     * does not support non-keyed access.
     * &lt;p&gt;
     * This is the type that will be returned by the mappedReadMethod.
     */
    public Class&lt;?&gt; getMappedPropertyType() {
<span class="fc" id="L228">        return mappedPropertyTypeRef.get();</span>
    }

    /**
     * Gets the method that should be used to read one of the property value.
     *
     * @return The method that should be used to read the property value.
     * May return null if the property can't be read.
     */
    public Method getMappedReadMethod() {
<span class="fc" id="L238">        return mappedReadMethodRef.get();</span>
    }

    /**
     * Sets the method that should be used to read one of the property value.
     *
     * @param mappedGetter The mapped getter method.
     * @throws IntrospectionException If an error occurs finding the
     * mapped property
     */
    public void setMappedReadMethod(final Method mappedGetter)
            throws IntrospectionException {
<span class="nc" id="L250">        mappedReadMethodRef = new MappedMethodReference(mappedGetter);</span>
<span class="nc" id="L251">        findMappedPropertyType();</span>
<span class="nc" id="L252">    }</span>

    /**
     * Gets the method that should be used to write one of the property value.
     *
     * @return The method that should be used to write one of the property value.
     * May return null if the property can't be written.
     */
    public Method getMappedWriteMethod() {
<span class="fc" id="L261">        return mappedWriteMethodRef.get();</span>
    }

    /**
     * Sets the method that should be used to write the property value.
     *
     * @param mappedSetter The mapped setter method.
     * @throws IntrospectionException If an error occurs finding the
     * mapped property
     */
    public void setMappedWriteMethod(final Method mappedSetter)
            throws IntrospectionException {
<span class="nc" id="L273">        mappedWriteMethodRef = new MappedMethodReference(mappedSetter);</span>
<span class="nc" id="L274">        findMappedPropertyType();</span>
<span class="nc" id="L275">    }</span>

    // ------------------------------------------------------- Private Methods

    /**
     * Introspect our bean class to identify the corresponding getter
     * and setter methods.
     */
    private void findMappedPropertyType() throws IntrospectionException {
        try {
<span class="fc" id="L285">            final Method mappedReadMethod  = getMappedReadMethod();</span>
<span class="fc" id="L286">            final Method mappedWriteMethod = getMappedWriteMethod();</span>
<span class="fc" id="L287">            Class&lt;?&gt; mappedPropertyType = null;</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">            if (mappedReadMethod != null) {</span>
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">                if (mappedReadMethod.getParameterTypes().length != 1) {</span>
<span class="nc" id="L290">                    throw new IntrospectionException</span>
                            (&quot;bad mapped read method arg count&quot;);
                }
<span class="fc" id="L293">                mappedPropertyType = mappedReadMethod.getReturnType();</span>
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">                if (mappedPropertyType == Void.TYPE) {</span>
<span class="nc" id="L295">                    throw new IntrospectionException</span>
                            (&quot;mapped read method &quot; +
<span class="nc" id="L297">                            mappedReadMethod.getName() + &quot; returns void&quot;);</span>
                }
            }

<span class="fc bfc" id="L301" title="All 2 branches covered.">            if (mappedWriteMethod != null) {</span>
<span class="fc" id="L302">                final Class&lt;?&gt;[] params = mappedWriteMethod.getParameterTypes();</span>
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">                if (params.length != 2) {</span>
<span class="nc" id="L304">                    throw new IntrospectionException</span>
                            (&quot;bad mapped write method arg count&quot;);
                }
<span class="pc bpc" id="L307" title="1 of 4 branches missed.">                if (mappedPropertyType != null &amp;&amp;</span>
                        mappedPropertyType != params[1]) {
<span class="nc" id="L309">                    throw new IntrospectionException</span>
                            (&quot;type mismatch between mapped read and write methods&quot;);
                }
<span class="fc" id="L312">                mappedPropertyType = params[1];</span>
            }
<span class="fc" id="L314">            mappedPropertyTypeRef = new SoftReference&lt;Class&lt;?&gt;&gt;(mappedPropertyType);</span>
<span class="nc" id="L315">        } catch (final IntrospectionException ex) {</span>
<span class="nc" id="L316">            throw ex;</span>
<span class="fc" id="L317">        }</span>
<span class="fc" id="L318">    }</span>


    /**
     * Return a capitalized version of the specified property name.
     *
     * @param s The property name
     */
    private static String capitalizePropertyName(final String s) {
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">        if (s.length() == 0) {</span>
<span class="nc" id="L328">            return s;</span>
        }

<span class="fc" id="L331">        final char[] chars = s.toCharArray();</span>
<span class="fc" id="L332">        chars[0] = Character.toUpperCase(chars[0]);</span>
<span class="fc" id="L333">        return new String(chars);</span>
    }

    /**
     * Find a method on a class with a specified number of parameters.
     */
    private static Method internalGetMethod(final Class&lt;?&gt; initial, final String methodName,
                                            final int parameterCount) {
        // For overridden methods we need to find the most derived version.
        // So we start with the given class and walk up the superclass chain.
<span class="fc bfc" id="L343" title="All 2 branches covered.">        for (Class&lt;?&gt; clazz = initial; clazz != null; clazz = clazz.getSuperclass()) {</span>
<span class="fc" id="L344">            final Method[] methods = clazz.getDeclaredMethods();</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">            for (final Method method : methods) {</span>
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">                if (method == null) {</span>
<span class="nc" id="L347">                    continue;</span>
                }
                // skip static methods.
<span class="fc" id="L350">                final int mods = method.getModifiers();</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">                if (!Modifier.isPublic(mods) ||</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">                    Modifier.isStatic(mods)) {</span>
<span class="fc" id="L353">                    continue;</span>
                }
<span class="fc bfc" id="L355" title="All 2 branches covered.">                if (method.getName().equals(methodName) &amp;&amp;</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">                        method.getParameterTypes().length == parameterCount) {</span>
<span class="fc" id="L357">                    return method;</span>
                }
            }
        }

        // Now check any inherited interfaces.  This is necessary both when
        // the argument class is itself an interface, and when the argument
        // class is an abstract class.
<span class="fc" id="L365">        final Class&lt;?&gt;[] interfaces = initial.getInterfaces();</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">        for (final Class&lt;?&gt; interface1 : interfaces) {</span>
<span class="fc" id="L367">            final Method method = internalGetMethod(interface1, methodName, parameterCount);</span>
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">            if (method != null) {</span>
<span class="nc" id="L369">                return method;</span>
            }
        }

<span class="fc" id="L373">        return null;</span>
    }

    /**
     * Find a method on a class with a specified number of parameters.
     */
    private static Method getMethod(final Class&lt;?&gt; clazz, final String methodName, final int parameterCount)
            throws IntrospectionException {
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">        if (methodName == null) {</span>
<span class="nc" id="L382">            return null;</span>
        }

<span class="fc" id="L385">        final Method method = internalGetMethod(clazz, methodName, parameterCount);</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">        if (method != null) {</span>
<span class="fc" id="L387">            return method;</span>
        }

        // No Method found
<span class="fc" id="L391">        throw new IntrospectionException(&quot;No method \&quot;&quot; + methodName +</span>
                &quot;\&quot; with &quot; + parameterCount + &quot; parameter(s)&quot;);
    }

    /**
     * Find a method on a class with a specified parameter list.
     */
    private static Method getMethod(final Class&lt;?&gt; clazz, final String methodName, final Class&lt;?&gt;[] parameterTypes)
                                           throws IntrospectionException {
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">        if (methodName == null) {</span>
<span class="nc" id="L401">            return null;</span>
        }

<span class="fc" id="L404">        final Method method = MethodUtils.getMatchingAccessibleMethod(clazz, methodName, parameterTypes);</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">        if (method != null) {</span>
<span class="fc" id="L406">            return method;</span>
        }

<span class="pc bpc" id="L409" title="1 of 2 branches missed.">        final int parameterCount = parameterTypes == null ? 0 : parameterTypes.length;</span>

        // No Method found
<span class="fc" id="L412">        throw new IntrospectionException(&quot;No method \&quot;&quot; + methodName +</span>
                &quot;\&quot; with &quot; + parameterCount + &quot; parameter(s) of matching types.&quot;);
    }

    /**
     * Holds a {@link Method} in a {@link SoftReference} so that it
     * it doesn't prevent any ClassLoader being garbage collected, but
     * tries to re-create the method if the method reference has been
     * released.
     *
     * See http://issues.apache.org/jira/browse/BEANUTILS-291
     */
    private static class MappedMethodReference {
        private String className;
        private String methodName;
        private Reference&lt;Method&gt; methodRef;
        private Reference&lt;Class&lt;?&gt;&gt; classRef;
        private Reference&lt;Class&lt;?&gt;&gt; writeParamTypeRef0;
        private Reference&lt;Class&lt;?&gt;&gt; writeParamTypeRef1;
        private String[] writeParamClassNames;
<span class="fc" id="L432">        MappedMethodReference(final Method m) {</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">            if (m != null) {</span>
<span class="fc" id="L434">                className = m.getDeclaringClass().getName();</span>
<span class="fc" id="L435">                methodName = m.getName();</span>
<span class="fc" id="L436">                methodRef = new SoftReference&lt;&gt;(m);</span>
<span class="fc" id="L437">                classRef = new WeakReference&lt;Class&lt;?&gt;&gt;(m.getDeclaringClass());</span>
<span class="fc" id="L438">                final Class&lt;?&gt;[] types = m.getParameterTypes();</span>
<span class="fc bfc" id="L439" title="All 2 branches covered.">                if (types.length == 2) {</span>
<span class="fc" id="L440">                    writeParamTypeRef0 = new WeakReference&lt;Class&lt;?&gt;&gt;(types[0]);</span>
<span class="fc" id="L441">                    writeParamTypeRef1 = new WeakReference&lt;Class&lt;?&gt;&gt;(types[1]);</span>
<span class="fc" id="L442">                    writeParamClassNames = new String[2];</span>
<span class="fc" id="L443">                    writeParamClassNames[0] = types[0].getName();</span>
<span class="fc" id="L444">                    writeParamClassNames[1] = types[1].getName();</span>
                }
            }
<span class="fc" id="L447">        }</span>
        private Method get() {
<span class="fc bfc" id="L449" title="All 2 branches covered.">            if (methodRef == null) {</span>
<span class="fc" id="L450">                return null;</span>
            }
<span class="fc" id="L452">            Method m = methodRef.get();</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">            if (m == null) {</span>
<span class="fc" id="L454">                Class&lt;?&gt; clazz = classRef.get();</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">                if (clazz == null) {</span>
<span class="fc" id="L456">                    clazz = reLoadClass();</span>
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">                    if (clazz != null) {</span>
<span class="fc" id="L458">                        classRef = new WeakReference&lt;Class&lt;?&gt;&gt;(clazz);</span>
                    }
                }
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">                if (clazz == null) {</span>
<span class="nc" id="L462">                    throw new RuntimeException(&quot;Method &quot; + methodName + &quot; for &quot; +</span>
                            className + &quot; could not be reconstructed - class reference has gone&quot;);
                }
<span class="fc" id="L465">                Class&lt;?&gt;[] paramTypes = null;</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">                if (writeParamClassNames != null) {</span>
<span class="fc" id="L467">                    paramTypes = new Class[2];</span>
<span class="fc" id="L468">                    paramTypes[0] = writeParamTypeRef0.get();</span>
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">                    if (paramTypes[0] == null) {</span>
<span class="nc" id="L470">                        paramTypes[0] = reLoadClass(writeParamClassNames[0]);</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">                        if (paramTypes[0] != null) {</span>
<span class="nc" id="L472">                            writeParamTypeRef0 = new WeakReference&lt;Class&lt;?&gt;&gt;(paramTypes[0]);</span>
                        }
                    }
<span class="fc" id="L475">                    paramTypes[1] = writeParamTypeRef1.get();</span>
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">                    if (paramTypes[1] == null) {</span>
<span class="nc" id="L477">                        paramTypes[1] = reLoadClass(writeParamClassNames[1]);</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">                        if (paramTypes[1] != null) {</span>
<span class="nc" id="L479">                            writeParamTypeRef1 = new WeakReference&lt;Class&lt;?&gt;&gt;(paramTypes[1]);</span>
                        }
                    }
                } else {
<span class="fc" id="L483">                    paramTypes = STRING_CLASS_PARAMETER;</span>
                }
                try {
<span class="fc" id="L486">                    m = clazz.getMethod(methodName, paramTypes);</span>
                    // Un-comment following line for testing
                    // System.out.println(&quot;Recreated Method &quot; + methodName + &quot; for &quot; + className);
<span class="nc" id="L489">                } catch (final NoSuchMethodException e) {</span>
<span class="nc" id="L490">                    throw new RuntimeException(&quot;Method &quot; + methodName + &quot; for &quot; +</span>
                            className + &quot; could not be reconstructed - method not found&quot;);
<span class="fc" id="L492">                }</span>
<span class="fc" id="L493">                methodRef = new SoftReference&lt;&gt;(m);</span>
            }
<span class="fc" id="L495">            return m;</span>
        }

        /**
         * Try to re-load the class
         */
        private Class&lt;?&gt; reLoadClass() {
<span class="fc" id="L502">            return reLoadClass(className);</span>
        }

        /**
         * Try to re-load the class
         */
        private Class&lt;?&gt; reLoadClass(final String name) {

<span class="fc" id="L510">            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span>

            // Try the context class loader
<span class="pc bpc" id="L513" title="1 of 2 branches missed.">            if (classLoader != null) {</span>
                try {
<span class="fc" id="L515">                    return classLoader.loadClass(name);</span>
<span class="nc" id="L516">                } catch (final ClassNotFoundException e) {</span>
                    // ignore
                }
            }

            // Try this class's class loader
<span class="nc" id="L522">            classLoader = MappedPropertyDescriptor.class.getClassLoader();</span>
            try {
<span class="nc" id="L524">                return classLoader.loadClass(name);</span>
<span class="nc" id="L525">            } catch (final ClassNotFoundException e) {</span>
<span class="nc" id="L526">                return null;</span>
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>