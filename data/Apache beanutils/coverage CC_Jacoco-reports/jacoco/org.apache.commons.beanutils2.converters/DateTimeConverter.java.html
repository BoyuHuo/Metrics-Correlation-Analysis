<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DateTimeConverter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons BeanUtils</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.beanutils2.converters</a> &gt; <span class="el_source">DateTimeConverter.java</span></div><h1>DateTimeConverter.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.beanutils2.converters;

import java.text.DateFormat;
import java.text.ParsePosition;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.Locale;
import java.util.TimeZone;

import org.apache.commons.beanutils2.ConversionException;

/**
 * {@link org.apache.commons.beanutils2.Converter} implementaion
 * that handles conversion to and from &lt;b&gt;date/time&lt;/b&gt; objects.
 * &lt;p&gt;
 * This implementation handles conversion for the following
 * &lt;i&gt;date/time&lt;/i&gt; types.
 * &lt;ul&gt;
 *     &lt;li&gt;&lt;code&gt;java.util.Date&lt;/code&gt;&lt;/li&gt;
 *     &lt;li&gt;&lt;code&gt;java.util.Calendar&lt;/code&gt;&lt;/li&gt;
 *     &lt;li&gt;&lt;code&gt;java.sql.Date&lt;/code&gt;&lt;/li&gt;
 *     &lt;li&gt;&lt;code&gt;java.sql.Time&lt;/code&gt;&lt;/li&gt;
 *     &lt;li&gt;&lt;code&gt;java.sql.Timestamp&lt;/code&gt;&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;h3&gt;String Conversions (to and from)&lt;/h3&gt;
 * This class provides a number of ways in which date/time
 * conversions to/from Strings can be achieved:
 * &lt;ul&gt;
 *    &lt;li&gt;Using the SHORT date format for the default Locale, configure using:
 *        &lt;ul&gt;
 *           &lt;li&gt;&lt;code&gt;setUseLocaleFormat(true)&lt;/code&gt;&lt;/li&gt;
 *        &lt;/ul&gt;
 *    &lt;/li&gt;
 *    &lt;li&gt;Using the SHORT date format for a specified Locale, configure using:
 *        &lt;ul&gt;
 *           &lt;li&gt;&lt;code&gt;setLocale(Locale)&lt;/code&gt;&lt;/li&gt;
 *        &lt;/ul&gt;
 *    &lt;/li&gt;
 *    &lt;li&gt;Using the specified date pattern(s) for the default Locale, configure using:
 *        &lt;ul&gt;
 *           &lt;li&gt;Either &lt;code&gt;setPattern(String)&lt;/code&gt; or
 *                      &lt;code&gt;setPatterns(String[])&lt;/code&gt;&lt;/li&gt;
 *        &lt;/ul&gt;
 *    &lt;/li&gt;
 *    &lt;li&gt;Using the specified date pattern(s) for a specified Locale, configure using:
 *        &lt;ul&gt;
 *           &lt;li&gt;&lt;code&gt;setPattern(String)&lt;/code&gt; or
 *                    &lt;code&gt;setPatterns(String[]) and...&lt;/code&gt;&lt;/li&gt;
 *           &lt;li&gt;&lt;code&gt;setLocale(Locale)&lt;/code&gt;&lt;/li&gt;
 *        &lt;/ul&gt;
 *    &lt;/li&gt;
 *    &lt;li&gt;If none of the above are configured the
 *        &lt;code&gt;toDate(String)&lt;/code&gt; method is used to convert
 *        from String to Date and the Dates's
 *        &lt;code&gt;toString()&lt;/code&gt; method used to convert from
 *        Date to String.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 * The &lt;b&gt;Time Zone&lt;/b&gt; to use with the date format can be specified
 * using the {@link #setTimeZone(TimeZone)} method.
 *
 * @version $Id$
 * @since 1.8.0
 */
public abstract class DateTimeConverter extends AbstractConverter {

    private String[] patterns;
    private String displayPatterns;
    private Locale locale;
    private TimeZone timeZone;
    private boolean useLocaleFormat;


    // ----------------------------------------------------------- Constructors

    /**
     * Construct a Date/Time &lt;i&gt;Converter&lt;/i&gt; that throws a
     * &lt;code&gt;ConversionException&lt;/code&gt; if an error occurs.
     */
    public DateTimeConverter() {
<span class="fc" id="L100">        super();</span>
<span class="fc" id="L101">    }</span>

    /**
     * Construct a Date/Time &lt;i&gt;Converter&lt;/i&gt; that returns a default
     * value if an error occurs.
     *
     * @param defaultValue The default value to be returned
     * if the value to be converted is missing or an error
     * occurs converting the value.
     */
    public DateTimeConverter(final Object defaultValue) {
<span class="fc" id="L112">        super(defaultValue);</span>
<span class="fc" id="L113">    }</span>


    // --------------------------------------------------------- Public Methods

    /**
     * Indicate whether conversion should use a format/pattern or not.
     *
     * @param useLocaleFormat &lt;code&gt;true&lt;/code&gt; if the format
     * for the locale should be used, otherwise &lt;code&gt;false&lt;/code&gt;
     */
    public void setUseLocaleFormat(final boolean useLocaleFormat) {
<span class="fc" id="L125">        this.useLocaleFormat = useLocaleFormat;</span>
<span class="fc" id="L126">    }</span>

    /**
     * Return the Time Zone to use when converting dates
     * (or &lt;code&gt;null&lt;/code&gt; if none specified.
     *
     * @return The Time Zone.
     */
    public TimeZone getTimeZone() {
<span class="nc" id="L135">        return timeZone;</span>
    }

    /**
     * Set the Time Zone to use when converting dates.
     *
     * @param timeZone The Time Zone.
     */
    public void setTimeZone(final TimeZone timeZone) {
<span class="nc" id="L144">        this.timeZone = timeZone;</span>
<span class="nc" id="L145">    }</span>

    /**
     * Return the Locale for the &lt;i&gt;Converter&lt;/i&gt;
     * (or &lt;code&gt;null&lt;/code&gt; if none specified).
     *
     * @return The locale to use for conversion
     */
    public Locale getLocale() {
<span class="nc" id="L154">        return locale;</span>
    }

    /**
     * Set the Locale for the &lt;i&gt;Converter&lt;/i&gt;.
     *
     * @param locale The Locale.
     */
    public void setLocale(final Locale locale) {
<span class="fc" id="L163">        this.locale = locale;</span>
<span class="fc" id="L164">        setUseLocaleFormat(true);</span>
<span class="fc" id="L165">    }</span>

    /**
     * Set a date format pattern to use to convert
     * dates to/from a &lt;code&gt;java.lang.String&lt;/code&gt;.
     *
     * @see SimpleDateFormat
     * @param pattern The format pattern.
     */
    public void setPattern(final String pattern) {
<span class="fc" id="L175">        setPatterns(new String[] {pattern});</span>
<span class="fc" id="L176">    }</span>

    /**
     * Return the date format patterns used to convert
     * dates to/from a &lt;code&gt;java.lang.String&lt;/code&gt;
     * (or &lt;code&gt;null&lt;/code&gt; if none specified).
     *
     * @see SimpleDateFormat
     * @return Array of format patterns.
     */
    public String[] getPatterns() {
<span class="nc" id="L187">        return patterns;</span>
    }

    /**
     * Set the date format patterns to use to convert
     * dates to/from a &lt;code&gt;java.lang.String&lt;/code&gt;.
     *
     * @see SimpleDateFormat
     * @param patterns Array of format patterns.
     */
    public void setPatterns(final String[] patterns) {
<span class="fc" id="L198">        this.patterns = patterns;</span>
<span class="pc bpc" id="L199" title="1 of 4 branches missed.">        if (patterns != null &amp;&amp; patterns.length &gt; 1) {</span>
<span class="fc" id="L200">            final StringBuilder buffer = new StringBuilder();</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">            for (int i = 0; i &lt; patterns.length; i++) {</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">                if (i &gt; 0) {</span>
<span class="fc" id="L203">                    buffer.append(&quot;, &quot;);</span>
                }
<span class="fc" id="L205">                buffer.append(patterns[i]);</span>
            }
<span class="fc" id="L207">            displayPatterns = buffer.toString();</span>
        }
<span class="fc" id="L209">        setUseLocaleFormat(true);</span>
<span class="fc" id="L210">    }</span>

    // ------------------------------------------------------ Protected Methods

    /**
     * Convert an input Date/Calendar object into a String.
     * &lt;p&gt;
     * &lt;b&gt;N.B.&lt;/b&gt;If the converter has been configured to with
     * one or more patterns (using &lt;code&gt;setPatterns()&lt;/code&gt;), then
     * the first pattern will be used to format the date into a String.
     * Otherwise the default &lt;code&gt;DateFormat&lt;/code&gt; for the default locale
     * (and &lt;i&gt;style&lt;/i&gt; if configured) will be used.
     *
     * @param value The input value to be converted
     * @return the converted String value.
     * @throws Throwable if an error occurs converting to a String
     */
    @Override
    protected String convertToString(final Object value) throws Throwable {

<span class="fc" id="L230">        Date date = null;</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">        if (value instanceof Date) {</span>
<span class="fc" id="L232">            date = (Date)value;</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">        } else if (value instanceof Calendar) {</span>
<span class="fc" id="L234">            date = ((Calendar)value).getTime();</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">        } else if (value instanceof Long) {</span>
<span class="nc" id="L236">            date = new Date(((Long)value).longValue());</span>
        }

<span class="fc" id="L239">        String result = null;</span>
<span class="fc bfc" id="L240" title="All 4 branches covered.">        if (useLocaleFormat &amp;&amp; date != null) {</span>
<span class="fc" id="L241">            DateFormat format = null;</span>
<span class="pc bpc" id="L242" title="1 of 4 branches missed.">            if (patterns != null &amp;&amp; patterns.length &gt; 0) {</span>
<span class="fc" id="L243">                format = getFormat(patterns[0]);</span>
            } else {
<span class="fc" id="L245">                format = getFormat(locale, timeZone);</span>
            }
<span class="fc" id="L247">            logFormat(&quot;Formatting&quot;, format);</span>
<span class="fc" id="L248">            result = format.format(date);</span>
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">            if (log().isDebugEnabled()) {</span>
<span class="nc" id="L250">                log().debug(&quot;    Converted  to String using format '&quot; + result + &quot;'&quot;);</span>
            }
<span class="fc" id="L252">        } else {</span>
<span class="fc" id="L253">            result = value.toString();</span>
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">            if (log().isDebugEnabled()) {</span>
<span class="nc" id="L255">                log().debug(&quot;    Converted  to String using toString() '&quot; + result + &quot;'&quot;);</span>
             }
        }
<span class="fc" id="L258">        return result;</span>
    }

    /**
     * Convert the input object into a Date object of the
     * specified type.
     * &lt;p&gt;
     * This method handles conversions between the following
     * types:
     * &lt;ul&gt;
     *     &lt;li&gt;&lt;code&gt;java.util.Date&lt;/code&gt;&lt;/li&gt;
     *     &lt;li&gt;&lt;code&gt;java.util.Calendar&lt;/code&gt;&lt;/li&gt;
     *     &lt;li&gt;&lt;code&gt;java.sql.Date&lt;/code&gt;&lt;/li&gt;
     *     &lt;li&gt;&lt;code&gt;java.sql.Time&lt;/code&gt;&lt;/li&gt;
     *     &lt;li&gt;&lt;code&gt;java.sql.Timestamp&lt;/code&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * It also handles conversion from a &lt;code&gt;String&lt;/code&gt; to
     * any of the above types.
     * &lt;p&gt;
     *
     * For &lt;code&gt;String&lt;/code&gt; conversion, if the converter has been configured
     * with one or more patterns (using &lt;code&gt;setPatterns()&lt;/code&gt;), then
     * the conversion is attempted with each of the specified patterns.
     * Otherwise the default &lt;code&gt;DateFormat&lt;/code&gt; for the default locale
     * (and &lt;i&gt;style&lt;/i&gt; if configured) will be used.
     *
     * @param &lt;T&gt; The desired target type of the conversion.
     * @param targetType Data type to which this value should be converted.
     * @param value The input value to be converted.
     * @return The converted value.
     * @throws Exception if conversion cannot be performed successfully
     */
    @Override
    protected &lt;T&gt; T convertToType(final Class&lt;T&gt; targetType, final Object value) throws Exception {

<span class="fc" id="L294">        final Class&lt;?&gt; sourceType = value.getClass();</span>

        // Handle java.sql.Timestamp
<span class="fc bfc" id="L297" title="All 2 branches covered.">        if (value instanceof java.sql.Timestamp) {</span>

            // ---------------------- JDK 1.3 Fix ----------------------
            // N.B. Prior to JDK 1.4 the Timestamp's getTime() method
            //      didn't include the milliseconds. The following code
            //      ensures it works consistently accross JDK versions
<span class="fc" id="L303">            final java.sql.Timestamp timestamp = (java.sql.Timestamp)value;</span>
<span class="fc" id="L304">            long timeInMillis = ((timestamp.getTime() / 1000) * 1000);</span>
<span class="fc" id="L305">            timeInMillis += timestamp.getNanos() / 1000000;</span>
            // ---------------------- JDK 1.3 Fix ----------------------
<span class="fc" id="L307">            return toDate(targetType, timeInMillis);</span>
        }

        // Handle Date (includes java.sql.Date &amp; java.sql.Time)
<span class="fc bfc" id="L311" title="All 2 branches covered.">        if (value instanceof Date) {</span>
<span class="fc" id="L312">            final Date date = (Date)value;</span>
<span class="fc" id="L313">            return toDate(targetType, date.getTime());</span>
        }

        // Handle Calendar
<span class="fc bfc" id="L317" title="All 2 branches covered.">        if (value instanceof Calendar) {</span>
<span class="fc" id="L318">            final Calendar calendar = (Calendar)value;</span>
<span class="fc" id="L319">            return toDate(targetType, calendar.getTime().getTime());</span>
        }

        // Handle Long
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">        if (value instanceof Long) {</span>
<span class="nc" id="L324">            final Long longObj = (Long)value;</span>
<span class="nc" id="L325">            return toDate(targetType, longObj.longValue());</span>
        }

        // Convert all other types to String &amp; handle
<span class="fc" id="L329">        final String stringValue = value.toString().trim();</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">        if (stringValue.length() == 0) {</span>
<span class="fc" id="L331">            return handleMissing(targetType);</span>
        }

        // Parse the Date/Time
<span class="fc bfc" id="L335" title="All 2 branches covered.">        if (useLocaleFormat) {</span>
<span class="fc" id="L336">            Calendar calendar = null;</span>
<span class="pc bpc" id="L337" title="1 of 4 branches missed.">            if (patterns != null &amp;&amp; patterns.length &gt; 0) {</span>
<span class="fc" id="L338">                calendar = parse(sourceType, targetType, stringValue);</span>
            } else {
<span class="fc" id="L340">                final DateFormat format = getFormat(locale, timeZone);</span>
<span class="fc" id="L341">                calendar = parse(sourceType, targetType, stringValue, format);</span>
            }
<span class="fc bfc" id="L343" title="All 2 branches covered.">            if (Calendar.class.isAssignableFrom(targetType)) {</span>
<span class="fc" id="L344">                return targetType.cast(calendar);</span>
            }
<span class="fc" id="L346">            return toDate(targetType, calendar.getTime().getTime());</span>
        }

        // Default String conversion
<span class="fc" id="L350">        return toDate(targetType, stringValue);</span>

    }

    /**
     * Convert a long value to the specified Date type for this
     * &lt;i&gt;Converter&lt;/i&gt;.
     * &lt;p&gt;
     *
     * This method handles conversion to the following types:
     * &lt;ul&gt;
     *     &lt;li&gt;&lt;code&gt;java.util.Date&lt;/code&gt;&lt;/li&gt;
     *     &lt;li&gt;&lt;code&gt;java.util.Calendar&lt;/code&gt;&lt;/li&gt;
     *     &lt;li&gt;&lt;code&gt;java.sql.Date&lt;/code&gt;&lt;/li&gt;
     *     &lt;li&gt;&lt;code&gt;java.sql.Time&lt;/code&gt;&lt;/li&gt;
     *     &lt;li&gt;&lt;code&gt;java.sql.Timestamp&lt;/code&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param &lt;T&gt; The target type
     * @param type The Date type to convert to
     * @param value The long value to convert.
     * @return The converted date value.
     */
    private &lt;T&gt; T toDate(final Class&lt;T&gt; type, final long value) {

        // java.util.Date
<span class="fc bfc" id="L376" title="All 2 branches covered.">        if (type.equals(Date.class)) {</span>
<span class="fc" id="L377">            return type.cast(new Date(value));</span>
        }

        // java.sql.Date
<span class="fc bfc" id="L381" title="All 2 branches covered.">        if (type.equals(java.sql.Date.class)) {</span>
<span class="fc" id="L382">            return type.cast(new java.sql.Date(value));</span>
        }

        // java.sql.Time
<span class="fc bfc" id="L386" title="All 2 branches covered.">        if (type.equals(java.sql.Time.class)) {</span>
<span class="fc" id="L387">            return type.cast(new java.sql.Time(value));</span>
        }

        // java.sql.Timestamp
<span class="fc bfc" id="L391" title="All 2 branches covered.">        if (type.equals(java.sql.Timestamp.class)) {</span>
<span class="fc" id="L392">            return type.cast(new java.sql.Timestamp(value));</span>
        }

        // java.util.Calendar
<span class="fc bfc" id="L396" title="All 2 branches covered.">        if (type.equals(Calendar.class)) {</span>
<span class="fc" id="L397">            Calendar calendar = null;</span>
<span class="pc bpc" id="L398" title="2 of 4 branches missed.">            if (locale == null &amp;&amp; timeZone == null) {</span>
<span class="fc" id="L399">                calendar = Calendar.getInstance();</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">            } else if (locale == null) {</span>
<span class="nc" id="L401">                calendar = Calendar.getInstance(timeZone);</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">            } else if (timeZone == null) {</span>
<span class="nc" id="L403">                calendar = Calendar.getInstance(locale);</span>
            } else {
<span class="nc" id="L405">                calendar = Calendar.getInstance(timeZone, locale);</span>
            }
<span class="fc" id="L407">            calendar.setTime(new Date(value));</span>
<span class="fc" id="L408">            calendar.setLenient(false);</span>
<span class="fc" id="L409">            return type.cast(calendar);</span>
        }

<span class="fc" id="L412">        final String msg = toString(getClass()) + &quot; cannot handle conversion to '&quot;</span>
<span class="fc" id="L413">                   + toString(type) + &quot;'&quot;;</span>
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">        if (log().isWarnEnabled()) {</span>
<span class="fc" id="L415">            log().warn(&quot;    &quot; + msg);</span>
        }
<span class="fc" id="L417">        throw new ConversionException(msg);</span>
    }

    /**
     * Default String to Date conversion.
     * &lt;p&gt;
     * This method handles conversion from a String to the following types:
     * &lt;ul&gt;
     *     &lt;li&gt;&lt;code&gt;java.sql.Date&lt;/code&gt;&lt;/li&gt;
     *     &lt;li&gt;&lt;code&gt;java.sql.Time&lt;/code&gt;&lt;/li&gt;
     *     &lt;li&gt;&lt;code&gt;java.sql.Timestamp&lt;/code&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;
     * &lt;strong&gt;N.B.&lt;/strong&gt; No default String conversion
     * mechanism is provided for &lt;code&gt;java.util.Date&lt;/code&gt;
     * and &lt;code&gt;java.util.Calendar&lt;/code&gt; type.
     *
     * @param &lt;T&gt; The target type
     * @param type The date type to convert to
     * @param value The String value to convert.
     * @return The converted Number value.
     */
    private &lt;T&gt; T toDate(final Class&lt;T&gt; type, final String value) {
        // java.sql.Date
<span class="fc bfc" id="L441" title="All 2 branches covered.">        if (type.equals(java.sql.Date.class)) {</span>
            try {
<span class="fc" id="L443">                return type.cast(java.sql.Date.valueOf(value));</span>
<span class="fc" id="L444">            } catch (final IllegalArgumentException e) {</span>
<span class="fc" id="L445">                throw new ConversionException(</span>
                        &quot;String must be in JDBC format [yyyy-MM-dd] to create a java.sql.Date&quot;);
            }
        }

        // java.sql.Time
<span class="fc bfc" id="L451" title="All 2 branches covered.">        if (type.equals(java.sql.Time.class)) {</span>
            try {
<span class="fc" id="L453">                return type.cast(java.sql.Time.valueOf(value));</span>
<span class="fc" id="L454">            } catch (final IllegalArgumentException e) {</span>
<span class="fc" id="L455">                throw new ConversionException(</span>
                        &quot;String must be in JDBC format [HH:mm:ss] to create a java.sql.Time&quot;);
            }
        }

        // java.sql.Timestamp
<span class="fc bfc" id="L461" title="All 2 branches covered.">        if (type.equals(java.sql.Timestamp.class)) {</span>
            try {
<span class="fc" id="L463">                return type.cast(java.sql.Timestamp.valueOf(value));</span>
<span class="fc" id="L464">            } catch (final IllegalArgumentException e) {</span>
<span class="fc" id="L465">                throw new ConversionException(</span>
                        &quot;String must be in JDBC format [yyyy-MM-dd HH:mm:ss.fffffffff] &quot; +
                        &quot;to create a java.sql.Timestamp&quot;);
            }
        }

<span class="fc" id="L471">        final String msg = toString(getClass()) + &quot; does not support default String to '&quot;</span>
<span class="fc" id="L472">                   + toString(type) + &quot;' conversion.&quot;;</span>
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">        if (log().isWarnEnabled()) {</span>
<span class="fc" id="L474">            log().warn(&quot;    &quot; + msg);</span>
<span class="fc" id="L475">            log().warn(&quot;    (N.B. Re-configure Converter or use alternative implementation)&quot;);</span>
        }
<span class="fc" id="L477">        throw new ConversionException(msg);</span>
    }

    /**
     * Return a &lt;code&gt;DateFormat&lt;/code&gt; for the Locale.
     * @param locale The Locale to create the Format with (may be null)
     * @param timeZone The Time Zone create the Format with (may be null)
     *
     * @return A Date Format.
     */
    protected DateFormat getFormat(final Locale locale, final TimeZone timeZone) {
<span class="fc" id="L488">        DateFormat format = null;</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">        if (locale == null) {</span>
<span class="fc" id="L490">            format = DateFormat.getDateInstance(DateFormat.SHORT);</span>
        } else {
<span class="fc" id="L492">            format = DateFormat.getDateInstance(DateFormat.SHORT, locale);</span>
        }
<span class="pc bpc" id="L494" title="1 of 2 branches missed.">        if (timeZone != null) {</span>
<span class="nc" id="L495">            format.setTimeZone(timeZone);</span>
        }
<span class="fc" id="L497">        return format;</span>
    }

    /**
     * Create a date format for the specified pattern.
     *
     * @param pattern The date pattern
     * @return The DateFormat
     */
    private DateFormat getFormat(final String pattern) {
<span class="fc" id="L507">        final DateFormat format = new SimpleDateFormat(pattern);</span>
<span class="pc bpc" id="L508" title="1 of 2 branches missed.">        if (timeZone != null) {</span>
<span class="nc" id="L509">            format.setTimeZone(timeZone);</span>
        }
<span class="fc" id="L511">        return format;</span>
    }

    /**
     * Parse a String date value using the set of patterns.
     *
     * @param sourceType The type of the value being converted
     * @param targetType The type to convert the value to.
     * @param value The String date value.
     *
     * @return The converted Date object.
     * @throws Exception if an error occurs parsing the date.
     */
    private Calendar parse(final Class&lt;?&gt; sourceType, final Class&lt;?&gt; targetType, final String value) throws Exception {
<span class="fc" id="L525">        Exception firstEx = null;</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">        for (final String pattern : patterns) {</span>
            try {
<span class="fc" id="L528">                final DateFormat format = getFormat(pattern);</span>
<span class="fc" id="L529">                final Calendar calendar = parse(sourceType, targetType, value, format);</span>
<span class="fc" id="L530">                return calendar;</span>
<span class="fc" id="L531">            } catch (final Exception ex) {</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">                if (firstEx == null) {</span>
<span class="fc" id="L533">                    firstEx = ex;</span>
                }
            }
        }
<span class="fc bfc" id="L537" title="All 2 branches covered.">        if (patterns.length &gt; 1) {</span>
<span class="fc" id="L538">            throw new ConversionException(&quot;Error converting '&quot; + toString(sourceType) + &quot;' to '&quot; + toString(targetType)</span>
                    + &quot;' using  patterns '&quot; + displayPatterns + &quot;'&quot;);
        }
<span class="fc" id="L541">        throw firstEx;</span>
    }

    /**
     * Parse a String into a &lt;code&gt;Calendar&lt;/code&gt; object
     * using the specified &lt;code&gt;DateFormat&lt;/code&gt;.
     *
     * @param sourceType The type of the value being converted
     * @param targetType The type to convert the value to
     * @param value The String date value.
     * @param format The DateFormat to parse the String value.
     *
     * @return The converted Calendar object.
     * @throws ConversionException if the String cannot be converted.
     */
    private Calendar parse(final Class&lt;?&gt; sourceType, final Class&lt;?&gt; targetType, final String value, final DateFormat format) {
<span class="fc" id="L557">        logFormat(&quot;Parsing&quot;, format);</span>
<span class="fc" id="L558">        format.setLenient(false);</span>
<span class="fc" id="L559">        final ParsePosition pos = new ParsePosition(0);</span>
<span class="fc" id="L560">        final Date parsedDate = format.parse(value, pos); // ignore the result (use the Calendar)</span>
<span class="pc bpc" id="L561" title="1 of 6 branches missed.">        if (pos.getErrorIndex() &gt;= 0 || pos.getIndex() != value.length() || parsedDate == null) {</span>
<span class="fc" id="L562">            String msg = &quot;Error converting '&quot; + toString(sourceType) + &quot;' to '&quot; + toString(targetType) + &quot;'&quot;;</span>
<span class="pc bpc" id="L563" title="1 of 2 branches missed.">            if (format instanceof SimpleDateFormat) {</span>
<span class="fc" id="L564">                msg += &quot; using pattern '&quot; + ((SimpleDateFormat)format).toPattern() + &quot;'&quot;;</span>
            }
<span class="pc bpc" id="L566" title="1 of 2 branches missed.">            if (log().isDebugEnabled()) {</span>
<span class="nc" id="L567">                log().debug(&quot;    &quot; + msg);</span>
            }
<span class="fc" id="L569">            throw new ConversionException(msg);</span>
        }
<span class="fc" id="L571">        final Calendar calendar = format.getCalendar();</span>
<span class="fc" id="L572">        return calendar;</span>
    }

    /**
     * Provide a String representation of this date/time converter.
     *
     * @return A String representation of this date/time converter
     */
    @Override
    public String toString() {
<span class="fc" id="L582">        final StringBuilder buffer = new StringBuilder();</span>
<span class="fc" id="L583">        buffer.append(toString(getClass()));</span>
<span class="fc" id="L584">        buffer.append(&quot;[UseDefault=&quot;);</span>
<span class="fc" id="L585">        buffer.append(isUseDefault());</span>
<span class="fc" id="L586">        buffer.append(&quot;, UseLocaleFormat=&quot;);</span>
<span class="fc" id="L587">        buffer.append(useLocaleFormat);</span>
<span class="pc bpc" id="L588" title="1 of 2 branches missed.">        if (displayPatterns != null) {</span>
<span class="nc" id="L589">            buffer.append(&quot;, Patterns={&quot;);</span>
<span class="nc" id="L590">            buffer.append(displayPatterns);</span>
<span class="nc" id="L591">            buffer.append('}');</span>
        }
<span class="pc bpc" id="L593" title="1 of 2 branches missed.">        if (locale != null) {</span>
<span class="fc" id="L594">            buffer.append(&quot;, Locale=&quot;);</span>
<span class="fc" id="L595">            buffer.append(locale);</span>
        }
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">        if (timeZone != null) {</span>
<span class="nc" id="L598">            buffer.append(&quot;, TimeZone=&quot;);</span>
<span class="nc" id="L599">            buffer.append(timeZone);</span>
        }
<span class="fc" id="L601">        buffer.append(']');</span>
<span class="fc" id="L602">        return buffer.toString();</span>
    }

    /**
     * Log the &lt;code&gt;DateFormat&lt;/code&gt; creation.
     * @param action The action the format is being used for
     * @param format The Date format
     */
    private void logFormat(final String action, final DateFormat format) {
<span class="pc bpc" id="L611" title="1 of 2 branches missed.">        if (log().isDebugEnabled()) {</span>
<span class="nc" id="L612">            final StringBuilder buffer = new StringBuilder(45);</span>
<span class="nc" id="L613">            buffer.append(&quot;    &quot;);</span>
<span class="nc" id="L614">            buffer.append(action);</span>
<span class="nc" id="L615">            buffer.append(&quot; with Format&quot;);</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">            if (format instanceof SimpleDateFormat) {</span>
<span class="nc" id="L617">                buffer.append(&quot;[&quot;);</span>
<span class="nc" id="L618">                buffer.append(((SimpleDateFormat)format).toPattern());</span>
<span class="nc" id="L619">                buffer.append(&quot;]&quot;);</span>
            }
<span class="nc" id="L621">            buffer.append(&quot; for &quot;);</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">            if (locale == null) {</span>
<span class="nc" id="L623">                buffer.append(&quot;default locale&quot;);</span>
            } else {
<span class="nc" id="L625">                buffer.append(&quot;locale[&quot;);</span>
<span class="nc" id="L626">                buffer.append(locale);</span>
<span class="nc" id="L627">                buffer.append(&quot;]&quot;);</span>
            }
<span class="nc bnc" id="L629" title="All 2 branches missed.">            if (timeZone != null) {</span>
<span class="nc" id="L630">                buffer.append(&quot;, TimeZone[&quot;);</span>
<span class="nc" id="L631">                buffer.append(timeZone);</span>
<span class="nc" id="L632">                buffer.append(&quot;]&quot;);</span>
            }
<span class="nc" id="L634">            log().debug(buffer.toString());</span>
        }
<span class="fc" id="L636">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>